# verizon
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Verizon
  # Request for /api/v1/application/configurations/geofence PUT endpoint. It
  # requires at least one of vendorId, name, description, geofence, messages and
  # isActive fields to be populated.
  class GeoFenceConfigurationUpdateRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Name of the configuration.
    # @return [String]
    attr_accessor :name

    # Description of the configuration.
    # @return [String]
    attr_accessor :description

    # The GeoJSON representation of geofence. Geofence supports the following
    # geometry types: LineString, Polygon, MultiLineString, and MultiPolygon.
    # The system only supports a single Feature in the FeatureCollection, so
    # only one Line, Polygon, MultiLine or MultiPolygon can be defined within
    # one Geofencing configuration.
    # @return [EtxGeofence]
    attr_accessor :geo_fence

    # List of predefined messages that belongs to the geofence. These are the
    # messages that are sent out by the system when the Trigger Condition for
    # the message is met.
    # @return [Array[Object]]
    attr_accessor :messages

    # List of predefined messages that belongs to the geofence. These are the
    # messages that are sent out by the system when the Trigger Condition for
    # the message is met.
    # @return [TrueClass | FalseClass]
    attr_accessor :is_active

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['name'] = 'name'
      @_hash['description'] = 'description'
      @_hash['geo_fence'] = 'geoFence'
      @_hash['messages'] = 'messages'
      @_hash['is_active'] = 'isActive'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        name
        description
        geo_fence
        messages
        is_active
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(name: SKIP, description: SKIP, geo_fence: SKIP,
                   messages: SKIP, is_active: SKIP)
      @name = name unless name == SKIP
      @description = description unless description == SKIP
      @geo_fence = geo_fence unless geo_fence == SKIP
      @messages = messages unless messages == SKIP
      @is_active = is_active unless is_active == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      name = hash.key?('name') ? hash['name'] : SKIP
      description = hash.key?('description') ? hash['description'] : SKIP
      geo_fence = EtxGeofence.from_hash(hash['geoFence']) if hash['geoFence']
      messages = hash.key?('messages') ? hash['messages'] : SKIP
      is_active = hash.key?('isActive') ? hash['isActive'] : SKIP

      # Create object from extracted values.
      GeoFenceConfigurationUpdateRequest.new(name: name,
                                             description: description,
                                             geo_fence: geo_fence,
                                             messages: messages,
                                             is_active: is_active)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} name: #{@name}, description: #{@description}, geo_fence: #{@geo_fence},"\
      " messages: #{@messages}, is_active: #{@is_active}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} name: #{@name.inspect}, description: #{@description.inspect}, geo_fence:"\
      " #{@geo_fence.inspect}, messages: #{@messages.inspect}, is_active: #{@is_active.inspect}>"
    end
  end
end
