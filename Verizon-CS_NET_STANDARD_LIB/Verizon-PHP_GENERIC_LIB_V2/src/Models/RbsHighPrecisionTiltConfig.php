<?php

declare(strict_types=1);

/*
 * VerizonLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace VerizonLib\Models;

use stdClass;
use VerizonLib\ApiHelper;

class RbsHighPrecisionTiltConfig implements \JsonSerializable
{
    /**
     * @var string|null
     */
    private $mode;

    /**
     * @var PeriodicReporting|null
     */
    private $periodicReporting;

    /**
     * @var int|null
     */
    private $holdTime;

    /**
     * @var int|null
     */
    private $angleAway;

    /**
     * @var int|null
     */
    private $angleToward;

    /**
     * @var Tscore|null
     */
    private $tscore;

    /**
     * Returns Mode.
     * the reporting mode of the tilt sensor
     */
    public function getMode(): ?string
    {
        return $this->mode;
    }

    /**
     * Sets Mode.
     * the reporting mode of the tilt sensor
     *
     * @maps mode
     * @factory \VerizonLib\Models\Mode::checkValue
     */
    public function setMode(?string $mode): void
    {
        $this->mode = $mode;
    }

    /**
     * Returns Periodic Reporting.
     * The units and values of the time interval for the sensor to send a report
     */
    public function getPeriodicReporting(): ?PeriodicReporting
    {
        return $this->periodicReporting;
    }

    /**
     * Sets Periodic Reporting.
     * The units and values of the time interval for the sensor to send a report
     *
     * @maps periodic-reporting
     */
    public function setPeriodicReporting(?PeriodicReporting $periodicReporting): void
    {
        $this->periodicReporting = $periodicReporting;
    }

    /**
     * Returns Hold Time.
     * The time the threshold condition exists, in milliseconds, to recognize an event
     */
    public function getHoldTime(): ?int
    {
        return $this->holdTime;
    }

    /**
     * Sets Hold Time.
     * The time the threshold condition exists, in milliseconds, to recognize an event
     *
     * @maps hold-time
     */
    public function setHoldTime(?int $holdTime): void
    {
        $this->holdTime = $holdTime;
    }

    /**
     * Returns Angle Away.
     * the threshold value, from verticle, to recognize an event
     */
    public function getAngleAway(): ?int
    {
        return $this->angleAway;
    }

    /**
     * Sets Angle Away.
     * the threshold value, from verticle, to recognize an event
     *
     * @maps angle-away
     */
    public function setAngleAway(?int $angleAway): void
    {
        $this->angleAway = $angleAway;
    }

    /**
     * Returns Angle Toward.
     * the threshold value, moving towards  verticle, to recognize an event
     */
    public function getAngleToward(): ?int
    {
        return $this->angleToward;
    }

    /**
     * Sets Angle Toward.
     * the threshold value, moving towards  verticle, to recognize an event
     *
     * @maps angle-toward
     */
    public function setAngleToward(?int $angleToward): void
    {
        $this->angleToward = $angleToward;
    }

    /**
     * Returns Tscore.
     */
    public function getTscore(): ?Tscore
    {
        return $this->tscore;
    }

    /**
     * Sets Tscore.
     *
     * @maps tscore
     */
    public function setTscore(?Tscore $tscore): void
    {
        $this->tscore = $tscore;
    }

    /**
     * Converts the RbsHighPrecisionTiltConfig object to a human-readable string representation.
     *
     * @return string The string representation of the RbsHighPrecisionTiltConfig object.
     */
    public function __toString(): string
    {
        return ApiHelper::stringify(
            'RbsHighPrecisionTiltConfig',
            [
                'mode' => $this->mode,
                'periodicReporting' => $this->periodicReporting,
                'holdTime' => $this->holdTime,
                'angleAway' => $this->angleAway,
                'angleToward' => $this->angleToward,
                'tscore' => $this->tscore,
                'additionalProperties' => $this->additionalProperties
            ]
        );
    }

    protected $propertyNames = ['mode', 'periodic-reporting', 'hold-time', 'angle-away', 'angle-toward', 'tscore'];

    private $additionalProperties = [];

    /**
     * Add an additional property to this model.
     *
     * @param string $name Name of property.
     * @param mixed $value Value of property.
     */
    public function addAdditionalProperty(string $name, $value)
    {
        if (in_array($name, $this->propertyNames, true)) {
            throw new \InvalidArgumentException(
                "The additional property key, '$name' conflicts with one of the model's properties"
            );
        }

        $this->additionalProperties[$name] = $value;
    }

    /**
     * Find an additional property by name in this model or false if property does not exist.
     *
     * @param string $name Name of property.
     *
     * @return mixed|false Value of the property.
     */
    public function findAdditionalProperty(string $name)
    {
        if (isset($this->additionalProperties[$name])) {
            return $this->additionalProperties[$name];
        }
        return false;
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        if (isset($this->mode)) {
            $json['mode']               = Mode::checkValue($this->mode);
        }
        if (isset($this->periodicReporting)) {
            $json['periodic-reporting'] = $this->periodicReporting;
        }
        if (isset($this->holdTime)) {
            $json['hold-time']          = $this->holdTime;
        }
        if (isset($this->angleAway)) {
            $json['angle-away']         = $this->angleAway;
        }
        if (isset($this->angleToward)) {
            $json['angle-toward']       = $this->angleToward;
        }
        if (isset($this->tscore)) {
            $json['tscore']             = $this->tscore;
        }
        $json = array_merge($json, $this->additionalProperties);

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
