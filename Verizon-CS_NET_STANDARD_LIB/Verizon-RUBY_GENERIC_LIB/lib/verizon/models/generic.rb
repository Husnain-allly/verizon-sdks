# verizon
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Verizon
  # Custom message which is defined by the user and can support "any" message
  # type or format. **Note:** ETX prefers the j2735 or the j2735_gr encoding and
  # only vendor specific message types are allowed to be published in different
  # message formats.
  class Generic < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The type of message. This can be any of the standard V2X messages
    # specified in the SAE J2735 standard (e.g. BSM, PSM, RSA, TIM, MAP, SPAT,
    # etc.), or it can be a vendor specific message type that is not defined by
    # the standard.
    # @return [String]
    attr_accessor :message_type

    # The encoding of the message (e.g. j2735, protobuf, json, Avro, etc.). If
    # the message is encapsulated within a GeoRoutedMsg protocol buffer wrapper,
    # append _gr to the message format (e.g. j2735 => j2735_gr).
    # **Note:** ETX prefers the j2735 or the j2735_gr encoding and only vendor
    # specific message types are allowed to be published in different message
    # formats.
    # @return [String]
    attr_accessor :message_format

    # The base64 encoded message.
    # @return [String]
    attr_accessor :payload

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['message_type'] = 'messageType'
      @_hash['message_format'] = 'messageFormat'
      @_hash['payload'] = 'payload'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      []
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(message_type:, message_format:, payload:)
      @message_type = message_type
      @message_format = message_format
      @payload = payload
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      message_type = hash.key?('messageType') ? hash['messageType'] : nil
      message_format = hash.key?('messageFormat') ? hash['messageFormat'] : nil
      payload = hash.key?('payload') ? hash['payload'] : nil

      # Create object from extracted values.
      Generic.new(message_type: message_type,
                  message_format: message_format,
                  payload: payload)
    end

    # Validates an instance of the object from a given value.
    # @param [Generic | Hash] The value against the validation is performed.
    def self.validate(value)
      if value.instance_of? self
        return (
          APIHelper.valid_type?(value.message_type,
                                ->(val) { val.instance_of? String }) and
            APIHelper.valid_type?(value.message_format,
                                  ->(val) { val.instance_of? String }) and
            APIHelper.valid_type?(value.payload,
                                  ->(val) { val.instance_of? String })
        )
      end

      return false unless value.instance_of? Hash

      (
        APIHelper.valid_type?(value['messageType'],
                              ->(val) { val.instance_of? String }) and
          APIHelper.valid_type?(value['messageFormat'],
                                ->(val) { val.instance_of? String }) and
          APIHelper.valid_type?(value['payload'],
                                ->(val) { val.instance_of? String })
      )
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} message_type: #{@message_type}, message_format: #{@message_format},"\
      " payload: #{@payload}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} message_type: #{@message_type.inspect}, message_format:"\
      " #{@message_format.inspect}, payload: #{@payload.inspect}>"
    end
  end
end
