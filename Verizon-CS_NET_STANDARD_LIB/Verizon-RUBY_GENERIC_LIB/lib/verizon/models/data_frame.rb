# verizon
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Verizon
  # The data frame allows sending various advisory and road sign types of
  # information to equipped devices.
  class DataFrame < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Always set to 0 and carries no meaning. Legacy field maintained for
    # backward compatibility.
    # @return [Integer]
    attr_accessor :not_used

    # The frameType data element provides the type of message to follow in the
    # rest of the message frame structure. The following frame types are
    # supported:
    #  - unknown
    #  - advisory
    #  - roadSignage
    #  - commercialSignage
    # @return [FrameType]
    attr_accessor :frame_type

    # The frameType data element provides the type of message to follow in the
    # rest of the message frame structure. The following frame types are
    # supported:
    #  - unknown
    #  - advisory
    #  - roadSignage
    #  - commercialSignage
    # @return [Object]
    attr_accessor :msg_id

    # The V2X year consists of integer values from zero to 4095 representing the
    # year according to the Gregorian calendar date system. The value of zero
    # shall represent an unknown value.
    # @return [Integer]
    attr_accessor :start_year

    # Start time expresses the number of elapsed minutes of the current year in
    # the time system being used (typically UTC time). The value 527040 shall be
    # used for invalid.
    # @return [Integer]
    attr_accessor :start_time

    # The duration, in units of whole minutes, that a object persists for. A
    # value of 32000 means that the object persists forever. The range 0..32000
    # provides for about 22.2 days of maximum duration.
    # @return [Integer]
    attr_accessor :duration_time

    # The relative importance of the sign, on a scale from zero (least
    # important) to seven (most important).
    # @return [Integer]
    attr_accessor :priority

    # Always set to 0 and carries no meaning. Legacy field maintained for
    # backward compatibility.
    # @return [Integer]
    attr_accessor :not_used1

    # The data frame is used to support the cross-cutting need in many V2X
    # messages to describe arbitrary spatial areas (polygons, boundary lines,
    # and other basic shapes) required by various message types in a small
    # message size. This data frame can describe a complex path or region of
    # arbitrary size using either one of the two supported node offset methods
    # (XY offsets or LL offsets) or using simple geometric projections.
    # @return [Array[GeographicalPath]]
    attr_accessor :regions

    # Always set to 0 and carries no meaning. Legacy field maintained for
    # backward compatibility.
    # @return [Integer]
    attr_accessor :not_used2

    # Always set to 0 and carries no meaning. Legacy field maintained for
    # backward compatibility.
    # @return [Integer]
    attr_accessor :not_used3

    # Always set to 0 and carries no meaning. Legacy field maintained for
    # backward compatibility.
    # @return [Object]
    attr_accessor :content

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['not_used'] = 'notUsed'
      @_hash['frame_type'] = 'frameType'
      @_hash['msg_id'] = 'msgId'
      @_hash['start_year'] = 'startYear'
      @_hash['start_time'] = 'startTime'
      @_hash['duration_time'] = 'durationTime'
      @_hash['priority'] = 'priority'
      @_hash['not_used1'] = 'notUsed1'
      @_hash['regions'] = 'regions'
      @_hash['not_used2'] = 'notUsed2'
      @_hash['not_used3'] = 'notUsed3'
      @_hash['content'] = 'content'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        start_year
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(not_used:, frame_type:, msg_id:, start_time:, duration_time:,
                   priority:, not_used1:, regions:, not_used2:, not_used3:,
                   content:, start_year: SKIP)
      @not_used = not_used
      @frame_type = frame_type
      @msg_id = msg_id
      @start_year = start_year unless start_year == SKIP
      @start_time = start_time
      @duration_time = duration_time
      @priority = priority
      @not_used1 = not_used1
      @regions = regions
      @not_used2 = not_used2
      @not_used3 = not_used3
      @content = content
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      not_used = hash.key?('notUsed') ? hash['notUsed'] : nil
      frame_type = hash.key?('frameType') ? hash['frameType'] : nil
      msg_id = hash.key?('msgId') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:DataFrameMsgId), hash['msgId']
      ) : nil
      start_time = hash.key?('startTime') ? hash['startTime'] : nil
      duration_time = hash.key?('durationTime') ? hash['durationTime'] : nil
      priority = hash.key?('priority') ? hash['priority'] : nil
      not_used1 = hash.key?('notUsed1') ? hash['notUsed1'] : nil
      # Parameter is an array, so we need to iterate through it
      regions = nil
      unless hash['regions'].nil?
        regions = []
        hash['regions'].each do |structure|
          regions << (GeographicalPath.from_hash(structure) if structure)
        end
      end

      regions = nil unless hash.key?('regions')
      not_used2 = hash.key?('notUsed2') ? hash['notUsed2'] : nil
      not_used3 = hash.key?('notUsed3') ? hash['notUsed3'] : nil
      content = hash.key?('content') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:DataFrameContent), hash['content']
      ) : nil
      start_year = hash.key?('startYear') ? hash['startYear'] : SKIP

      # Create object from extracted values.
      DataFrame.new(not_used: not_used,
                    frame_type: frame_type,
                    msg_id: msg_id,
                    start_time: start_time,
                    duration_time: duration_time,
                    priority: priority,
                    not_used1: not_used1,
                    regions: regions,
                    not_used2: not_used2,
                    not_used3: not_used3,
                    content: content,
                    start_year: start_year)
    end

    # Validates an instance of the object from a given value.
    # @param [DataFrame | Hash] The value against the validation is performed.
    def self.validate(value)
      if value.instance_of? self
        return (
          APIHelper.valid_type?(value.not_used,
                                ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.frame_type,
                                  ->(val) { FrameType.validate(val) }) and
            UnionTypeLookUp.get(:DataFrameMsgId)
                           .validate(value.msg_id) and
            APIHelper.valid_type?(value.start_time,
                                  ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.duration_time,
                                  ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.priority,
                                  ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.not_used1,
                                  ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.regions,
                                  ->(val) { GeographicalPath.validate(val) },
                                  is_model_hash: true,
                                  is_inner_model_hash: true) and
            APIHelper.valid_type?(value.not_used2,
                                  ->(val) { val.instance_of? Integer }) and
            APIHelper.valid_type?(value.not_used3,
                                  ->(val) { val.instance_of? Integer }) and
            UnionTypeLookUp.get(:DataFrameContent)
                           .validate(value.content)
        )
      end

      return false unless value.instance_of? Hash

      (
        APIHelper.valid_type?(value['notUsed'],
                              ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['frameType'],
                                ->(val) { FrameType.validate(val) }) and
          UnionTypeLookUp.get(:DataFrameMsgId)
                         .validate(value['msgId']) and
          APIHelper.valid_type?(value['startTime'],
                                ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['durationTime'],
                                ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['priority'],
                                ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['notUsed1'],
                                ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['regions'],
                                ->(val) { GeographicalPath.validate(val) },
                                is_model_hash: true,
                                is_inner_model_hash: true) and
          APIHelper.valid_type?(value['notUsed2'],
                                ->(val) { val.instance_of? Integer }) and
          APIHelper.valid_type?(value['notUsed3'],
                                ->(val) { val.instance_of? Integer }) and
          UnionTypeLookUp.get(:DataFrameContent)
                         .validate(value['content'])
      )
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} not_used: #{@not_used}, frame_type: #{@frame_type}, msg_id: #{@msg_id},"\
      " start_year: #{@start_year}, start_time: #{@start_time}, duration_time: #{@duration_time},"\
      " priority: #{@priority}, not_used1: #{@not_used1}, regions: #{@regions}, not_used2:"\
      " #{@not_used2}, not_used3: #{@not_used3}, content: #{@content}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} not_used: #{@not_used.inspect}, frame_type: #{@frame_type.inspect}, msg_id:"\
      " #{@msg_id.inspect}, start_year: #{@start_year.inspect}, start_time:"\
      " #{@start_time.inspect}, duration_time: #{@duration_time.inspect}, priority:"\
      " #{@priority.inspect}, not_used1: #{@not_used1.inspect}, regions: #{@regions.inspect},"\
      " not_used2: #{@not_used2.inspect}, not_used3: #{@not_used3.inspect}, content:"\
      " #{@content.inspect}>"
    end
  end
end
