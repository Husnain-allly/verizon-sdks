/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// DeleteDevicesResult represents a DeleteDevicesResult struct.
// Response for a request made to delete a device.
type DeleteDevicesResult struct {
    // One object per device to be deleted. Each object must contain a kind and id element identifying the device.
    DeviceIds            *DeleteDevicesResultDeviceIds `json:"deviceIds,omitempty"`
    // “Success” if the device was deleted, or “Failed” if there was a problem.
    Status               *string                       `json:"status,omitempty"`
    // Not present if status=Success. One of these messages if status=Failed:The device is not in deactivate state.The user does not have access to delete the device.
    Message              *string                       `json:"message,omitempty"`
    AdditionalProperties map[string]interface{}        `json:"_"`
}

// String implements the fmt.Stringer interface for DeleteDevicesResult,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (d DeleteDevicesResult) String() string {
    return fmt.Sprintf(
    	"DeleteDevicesResult[DeviceIds=%v, Status=%v, Message=%v, AdditionalProperties=%v]",
    	d.DeviceIds, d.Status, d.Message, d.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for DeleteDevicesResult.
// It customizes the JSON marshaling process for DeleteDevicesResult objects.
func (d DeleteDevicesResult) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(d.AdditionalProperties,
        "deviceIds", "status", "message"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(d.toMap())
}

// toMap converts the DeleteDevicesResult object to a map representation for JSON marshaling.
func (d DeleteDevicesResult) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, d.AdditionalProperties)
    if d.DeviceIds != nil {
        structMap["deviceIds"] = d.DeviceIds.toMap()
    }
    if d.Status != nil {
        structMap["status"] = d.Status
    }
    if d.Message != nil {
        structMap["message"] = d.Message
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for DeleteDevicesResult.
// It customizes the JSON unmarshaling process for DeleteDevicesResult objects.
func (d *DeleteDevicesResult) UnmarshalJSON(input []byte) error {
    var temp tempDeleteDevicesResult
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "deviceIds", "status", "message")
    if err != nil {
    	return err
    }
    d.AdditionalProperties = additionalProperties
    
    d.DeviceIds = temp.DeviceIds
    d.Status = temp.Status
    d.Message = temp.Message
    return nil
}

// tempDeleteDevicesResult is a temporary struct used for validating the fields of DeleteDevicesResult.
type tempDeleteDevicesResult  struct {
    DeviceIds *DeleteDevicesResultDeviceIds `json:"deviceIds,omitempty"`
    Status    *string                       `json:"status,omitempty"`
    Message   *string                       `json:"message,omitempty"`
}
