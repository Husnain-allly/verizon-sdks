/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "strings"
)

// Message1 represents a Message1 struct.
type Message1 struct {
    // Defines whether the message is private or public.
    // Private messages are published under the Vendor ID defined in the configuration and only visible to devices of selected vendors.
    // Public messages are published under the Public vendor and are visible to all the users.
    IsPrivate            bool                   `json:"isPrivate"`
    // Type of the Road User.
    RoadUserType         []RoadUserTypes        `json:"roadUserType"`
    // Trigger conditions that define on which road user action the message will be sent. If multiple Trigger Conditions are defined any of them will trigger the message.
    TriggerConditions    []TriggerCondition     `json:"triggerConditions"`
    // List of limitations. These limitations can be used for making the trigger condition more precise by defining speed and motion direction requirements to be met before the messages are sent out.
    Limits               []Limits               `json:"limits,omitempty"`
    // Type of the distribution.
    DistributionType     []DistributionTypes    `json:"distributionType,omitempty"`
    // The distribution schedule parameters for broadcast messages.
    DistributionSchedule *DistributionSchedule  `json:"distributionSchedule,omitempty"`
    SaeAlert             SaeAlert               `json:"saeAlert"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for Message1,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (m Message1) String() string {
    return fmt.Sprintf(
    	"Message1[IsPrivate=%v, RoadUserType=%v, TriggerConditions=%v, Limits=%v, DistributionType=%v, DistributionSchedule=%v, SaeAlert=%v, AdditionalProperties=%v]",
    	m.IsPrivate, m.RoadUserType, m.TriggerConditions, m.Limits, m.DistributionType, m.DistributionSchedule, m.SaeAlert, m.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for Message1.
// It customizes the JSON marshaling process for Message1 objects.
func (m Message1) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(m.AdditionalProperties,
        "isPrivate", "roadUserType", "triggerConditions", "limits", "distributionType", "distributionSchedule", "saeAlert"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(m.toMap())
}

// toMap converts the Message1 object to a map representation for JSON marshaling.
func (m Message1) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, m.AdditionalProperties)
    structMap["isPrivate"] = m.IsPrivate
    structMap["roadUserType"] = m.RoadUserType
    structMap["triggerConditions"] = m.TriggerConditions
    if m.Limits != nil {
        structMap["limits"] = m.Limits
    }
    if m.DistributionType != nil {
        structMap["distributionType"] = m.DistributionType
    }
    if m.DistributionSchedule != nil {
        structMap["distributionSchedule"] = m.DistributionSchedule.toMap()
    }
    structMap["saeAlert"] = m.SaeAlert.toMap()
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for Message1.
// It customizes the JSON unmarshaling process for Message1 objects.
func (m *Message1) UnmarshalJSON(input []byte) error {
    var temp tempMessage1
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "isPrivate", "roadUserType", "triggerConditions", "limits", "distributionType", "distributionSchedule", "saeAlert")
    if err != nil {
    	return err
    }
    m.AdditionalProperties = additionalProperties
    
    m.IsPrivate = *temp.IsPrivate
    m.RoadUserType = *temp.RoadUserType
    m.TriggerConditions = *temp.TriggerConditions
    m.Limits = temp.Limits
    m.DistributionType = temp.DistributionType
    m.DistributionSchedule = temp.DistributionSchedule
    m.SaeAlert = *temp.SaeAlert
    return nil
}

// tempMessage1 is a temporary struct used for validating the fields of Message1.
type tempMessage1  struct {
    IsPrivate            *bool                 `json:"isPrivate"`
    RoadUserType         *[]RoadUserTypes      `json:"roadUserType"`
    TriggerConditions    *[]TriggerCondition   `json:"triggerConditions"`
    Limits               []Limits              `json:"limits,omitempty"`
    DistributionType     []DistributionTypes   `json:"distributionType,omitempty"`
    DistributionSchedule *DistributionSchedule `json:"distributionSchedule,omitempty"`
    SaeAlert             *SaeAlert             `json:"saeAlert"`
}

func (m *tempMessage1) validate() error {
    var errs []string
    if m.IsPrivate == nil {
        errs = append(errs, "required field `isPrivate` is missing for type `Message1`")
    }
    if m.RoadUserType == nil {
        errs = append(errs, "required field `roadUserType` is missing for type `Message1`")
    }
    if m.TriggerConditions == nil {
        errs = append(errs, "required field `triggerConditions` is missing for type `Message1`")
    }
    if m.SaeAlert == nil {
        errs = append(errs, "required field `saeAlert` is missing for type `Message1`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
