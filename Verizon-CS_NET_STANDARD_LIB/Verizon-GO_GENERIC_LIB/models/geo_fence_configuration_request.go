/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "strings"
)

// GeoFenceConfigurationRequest represents a GeoFenceConfigurationRequest struct.
// Request for /api/v1/application/configurations/geofence POST endpoint. It requires the vendorId, geofence, messages and isActive fields to be populated.
type GeoFenceConfigurationRequest struct {
    // Name of the configuration.
    Name        *string     `json:"name,omitempty"`
    // Description of the configuration.
    Description *string     `json:"description,omitempty"`
    // The GeoJSON representation of geofence. Geofence supports the following geometry types: LineString, Polygon, MultiLineString, and MultiPolygon. The system only supports a single Feature in the FeatureCollection, so only one Line, Polygon, MultiLine or MultiPolygon can be defined within one Geofencing configuration.
    GeoFence    EtxGeofence `json:"geoFence"`
    // List of predefined messages that belongs to the geofence. These are the messages that are sent out by the system when the Trigger Condition for the message is met.
    Messages    []Message3  `json:"messages"`
    IsActive    bool        `json:"isActive"`
}

// String implements the fmt.Stringer interface for GeoFenceConfigurationRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (g GeoFenceConfigurationRequest) String() string {
    return fmt.Sprintf(
    	"GeoFenceConfigurationRequest[Name=%v, Description=%v, GeoFence=%v, Messages=%v, IsActive=%v]",
    	g.Name, g.Description, g.GeoFence, g.Messages, g.IsActive)
}

// MarshalJSON implements the json.Marshaler interface for GeoFenceConfigurationRequest.
// It customizes the JSON marshaling process for GeoFenceConfigurationRequest objects.
func (g GeoFenceConfigurationRequest) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(g.toMap())
}

// toMap converts the GeoFenceConfigurationRequest object to a map representation for JSON marshaling.
func (g GeoFenceConfigurationRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    if g.Name != nil {
        structMap["name"] = g.Name
    }
    if g.Description != nil {
        structMap["description"] = g.Description
    }
    structMap["geoFence"] = g.GeoFence.toMap()
    structMap["messages"] = g.Messages
    structMap["isActive"] = g.IsActive
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for GeoFenceConfigurationRequest.
// It customizes the JSON unmarshaling process for GeoFenceConfigurationRequest objects.
func (g *GeoFenceConfigurationRequest) UnmarshalJSON(input []byte) error {
    var temp tempGeoFenceConfigurationRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    
    g.Name = temp.Name
    g.Description = temp.Description
    g.GeoFence = *temp.GeoFence
    g.Messages = *temp.Messages
    g.IsActive = *temp.IsActive
    return nil
}

// tempGeoFenceConfigurationRequest is a temporary struct used for validating the fields of GeoFenceConfigurationRequest.
type tempGeoFenceConfigurationRequest  struct {
    Name        *string      `json:"name,omitempty"`
    Description *string      `json:"description,omitempty"`
    GeoFence    *EtxGeofence `json:"geoFence"`
    Messages    *[]Message3  `json:"messages"`
    IsActive    *bool        `json:"isActive"`
}

func (g *tempGeoFenceConfigurationRequest) validate() error {
    var errs []string
    if g.GeoFence == nil {
        errs = append(errs, "required field `geoFence` is missing for type `GeoFenceConfigurationRequest`")
    }
    if g.Messages == nil {
        errs = append(errs, "required field `messages` is missing for type `GeoFenceConfigurationRequest`")
    }
    if g.IsActive == nil {
        errs = append(errs, "required field `isActive` is missing for type `GeoFenceConfigurationRequest`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
