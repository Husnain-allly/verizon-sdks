/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "strings"
)

// PlaceOfUse represents a PlaceOfUse struct.
// The customer name and the address of the device's primary place of use. Leave these fields empty to use the account profile address as the primary place of use. These values will be applied to all devices in the request.If the account is enabled for non-geographic MDNs and the device supports it, the primaryPlaceOfUse address will also be used to derive the MDN for the device.
type PlaceOfUse struct {
    // The customer address for the line's primary place of use, for line usage taxation.
    Address              Address                `json:"address"`
    // The customer name to be used for line usage taxation.
    CustomerName         CustomerName           `json:"customerName"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for PlaceOfUse,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (p PlaceOfUse) String() string {
    return fmt.Sprintf(
    	"PlaceOfUse[Address=%v, CustomerName=%v, AdditionalProperties=%v]",
    	p.Address, p.CustomerName, p.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for PlaceOfUse.
// It customizes the JSON marshaling process for PlaceOfUse objects.
func (p PlaceOfUse) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(p.AdditionalProperties,
        "address", "customerName"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(p.toMap())
}

// toMap converts the PlaceOfUse object to a map representation for JSON marshaling.
func (p PlaceOfUse) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, p.AdditionalProperties)
    structMap["address"] = p.Address.toMap()
    structMap["customerName"] = p.CustomerName.toMap()
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for PlaceOfUse.
// It customizes the JSON unmarshaling process for PlaceOfUse objects.
func (p *PlaceOfUse) UnmarshalJSON(input []byte) error {
    var temp tempPlaceOfUse
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "address", "customerName")
    if err != nil {
    	return err
    }
    p.AdditionalProperties = additionalProperties
    
    p.Address = *temp.Address
    p.CustomerName = *temp.CustomerName
    return nil
}

// tempPlaceOfUse is a temporary struct used for validating the fields of PlaceOfUse.
type tempPlaceOfUse  struct {
    Address      *Address      `json:"address"`
    CustomerName *CustomerName `json:"customerName"`
}

func (p *tempPlaceOfUse) validate() error {
    var errs []string
    if p.Address == nil {
        errs = append(errs, "required field `address` is missing for type `PlaceOfUse`")
    }
    if p.CustomerName == nil {
        errs = append(errs, "required field `customerName` is missing for type `PlaceOfUse`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
