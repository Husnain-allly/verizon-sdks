/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// UploadAndScheduleFileResponse represents a UploadAndScheduleFileResponse struct.
type UploadAndScheduleFileResponse struct {
    // Updgrade identifier.
    Id                     *string                `json:"id,omitempty"`
    // Account identifer.
    AccountName            *string                `json:"accountName,omitempty"`
    // The campaign name.
    CampaignName           *string                `json:"campaignName,omitempty"`
    // Software name.
    SoftwareName           *string                `json:"softwareName,omitempty"`
    // Old software name.
    SoftwareFrom           *string                `json:"softwareFrom,omitempty"`
    // New software name.
    SoftwareTo             *string                `json:"softwareTo,omitempty"`
    // The name of the file you are upgrading to.
    FileName               *string                `json:"fileName,omitempty"`
    // The version of the file you are upgrading to.
    FileVersion            *string                `json:"fileVersion,omitempty"`
    // Valid values
    DistributionType       *string                `json:"distributionType,omitempty"`
    // Applicable make.
    Make                   *string                `json:"make,omitempty"`
    // Applicable model.
    Model                  *string                `json:"model,omitempty"`
    // Campaign start date.
    StartDate              *string                `json:"startDate,omitempty"`
    // Campaign end date.
    EndDate                *string                `json:"endDate,omitempty"`
    // Specifies the starting date the client should download the package. If null, client downloads as soon as possible.
    DownloadAfterDate      *string                `json:"downloadAfterDate,omitempty"`
    // List of allowed download time windows.
    DownloadTimeWindowList []DownloadTimeWindow   `json:"downloadTimeWindowList,omitempty"`
    // The date after which you install the package. If null, install as soon as possible.
    InstallAfterDate       *string                `json:"installAfterDate,omitempty"`
    // List of allowed install time windows.
    InstallTimeWindowList  []DownloadTimeWindow   `json:"installTimeWindowList,omitempty"`
    // Device IMEI list.
    DeviceList             []string               `json:"deviceList,omitempty"`
    // Software update status.
    Status                 *string                `json:"status,omitempty"`
    AdditionalProperties   map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for UploadAndScheduleFileResponse,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (u UploadAndScheduleFileResponse) String() string {
    return fmt.Sprintf(
    	"UploadAndScheduleFileResponse[Id=%v, AccountName=%v, CampaignName=%v, SoftwareName=%v, SoftwareFrom=%v, SoftwareTo=%v, FileName=%v, FileVersion=%v, DistributionType=%v, Make=%v, Model=%v, StartDate=%v, EndDate=%v, DownloadAfterDate=%v, DownloadTimeWindowList=%v, InstallAfterDate=%v, InstallTimeWindowList=%v, DeviceList=%v, Status=%v, AdditionalProperties=%v]",
    	u.Id, u.AccountName, u.CampaignName, u.SoftwareName, u.SoftwareFrom, u.SoftwareTo, u.FileName, u.FileVersion, u.DistributionType, u.Make, u.Model, u.StartDate, u.EndDate, u.DownloadAfterDate, u.DownloadTimeWindowList, u.InstallAfterDate, u.InstallTimeWindowList, u.DeviceList, u.Status, u.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for UploadAndScheduleFileResponse.
// It customizes the JSON marshaling process for UploadAndScheduleFileResponse objects.
func (u UploadAndScheduleFileResponse) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(u.AdditionalProperties,
        "id", "accountName", "campaignName", "softwareName", "softwareFrom", "softwareTo", "fileName", "fileVersion", "distributionType", "make", "model", "startDate", "endDate", "downloadAfterDate", "downloadTimeWindowList", "installAfterDate", "installTimeWindowList", "deviceList", "status"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(u.toMap())
}

// toMap converts the UploadAndScheduleFileResponse object to a map representation for JSON marshaling.
func (u UploadAndScheduleFileResponse) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, u.AdditionalProperties)
    if u.Id != nil {
        structMap["id"] = u.Id
    }
    if u.AccountName != nil {
        structMap["accountName"] = u.AccountName
    }
    if u.CampaignName != nil {
        structMap["campaignName"] = u.CampaignName
    }
    if u.SoftwareName != nil {
        structMap["softwareName"] = u.SoftwareName
    }
    if u.SoftwareFrom != nil {
        structMap["softwareFrom"] = u.SoftwareFrom
    }
    if u.SoftwareTo != nil {
        structMap["softwareTo"] = u.SoftwareTo
    }
    if u.FileName != nil {
        structMap["fileName"] = u.FileName
    }
    if u.FileVersion != nil {
        structMap["fileVersion"] = u.FileVersion
    }
    if u.DistributionType != nil {
        structMap["distributionType"] = u.DistributionType
    }
    if u.Make != nil {
        structMap["make"] = u.Make
    }
    if u.Model != nil {
        structMap["model"] = u.Model
    }
    if u.StartDate != nil {
        structMap["startDate"] = u.StartDate
    }
    if u.EndDate != nil {
        structMap["endDate"] = u.EndDate
    }
    if u.DownloadAfterDate != nil {
        structMap["downloadAfterDate"] = u.DownloadAfterDate
    }
    if u.DownloadTimeWindowList != nil {
        structMap["downloadTimeWindowList"] = u.DownloadTimeWindowList
    }
    if u.InstallAfterDate != nil {
        structMap["installAfterDate"] = u.InstallAfterDate
    }
    if u.InstallTimeWindowList != nil {
        structMap["installTimeWindowList"] = u.InstallTimeWindowList
    }
    if u.DeviceList != nil {
        structMap["deviceList"] = u.DeviceList
    }
    if u.Status != nil {
        structMap["status"] = u.Status
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for UploadAndScheduleFileResponse.
// It customizes the JSON unmarshaling process for UploadAndScheduleFileResponse objects.
func (u *UploadAndScheduleFileResponse) UnmarshalJSON(input []byte) error {
    var temp tempUploadAndScheduleFileResponse
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "id", "accountName", "campaignName", "softwareName", "softwareFrom", "softwareTo", "fileName", "fileVersion", "distributionType", "make", "model", "startDate", "endDate", "downloadAfterDate", "downloadTimeWindowList", "installAfterDate", "installTimeWindowList", "deviceList", "status")
    if err != nil {
    	return err
    }
    u.AdditionalProperties = additionalProperties
    
    u.Id = temp.Id
    u.AccountName = temp.AccountName
    u.CampaignName = temp.CampaignName
    u.SoftwareName = temp.SoftwareName
    u.SoftwareFrom = temp.SoftwareFrom
    u.SoftwareTo = temp.SoftwareTo
    u.FileName = temp.FileName
    u.FileVersion = temp.FileVersion
    u.DistributionType = temp.DistributionType
    u.Make = temp.Make
    u.Model = temp.Model
    u.StartDate = temp.StartDate
    u.EndDate = temp.EndDate
    u.DownloadAfterDate = temp.DownloadAfterDate
    u.DownloadTimeWindowList = temp.DownloadTimeWindowList
    u.InstallAfterDate = temp.InstallAfterDate
    u.InstallTimeWindowList = temp.InstallTimeWindowList
    u.DeviceList = temp.DeviceList
    u.Status = temp.Status
    return nil
}

// tempUploadAndScheduleFileResponse is a temporary struct used for validating the fields of UploadAndScheduleFileResponse.
type tempUploadAndScheduleFileResponse  struct {
    Id                     *string              `json:"id,omitempty"`
    AccountName            *string              `json:"accountName,omitempty"`
    CampaignName           *string              `json:"campaignName,omitempty"`
    SoftwareName           *string              `json:"softwareName,omitempty"`
    SoftwareFrom           *string              `json:"softwareFrom,omitempty"`
    SoftwareTo             *string              `json:"softwareTo,omitempty"`
    FileName               *string              `json:"fileName,omitempty"`
    FileVersion            *string              `json:"fileVersion,omitempty"`
    DistributionType       *string              `json:"distributionType,omitempty"`
    Make                   *string              `json:"make,omitempty"`
    Model                  *string              `json:"model,omitempty"`
    StartDate              *string              `json:"startDate,omitempty"`
    EndDate                *string              `json:"endDate,omitempty"`
    DownloadAfterDate      *string              `json:"downloadAfterDate,omitempty"`
    DownloadTimeWindowList []DownloadTimeWindow `json:"downloadTimeWindowList,omitempty"`
    InstallAfterDate       *string              `json:"installAfterDate,omitempty"`
    InstallTimeWindowList  []DownloadTimeWindow `json:"installTimeWindowList,omitempty"`
    DeviceList             []string             `json:"deviceList,omitempty"`
    Status                 *string              `json:"status,omitempty"`
}
