/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "strings"
)

// Address represents a Address struct.
// The customer address for the line's primary place of use, for line usage taxation.
type Address struct {
    // The street address for the line's primary place of use. This must be a physical address for taxation; it cannot be a P.O. box.
    AddressLine1         string                 `json:"addressLine1"`
    // Optional additional street address information.
    AddressLine2         *string                `json:"addressLine2,omitempty"`
    // The city for the line's primary place of use.
    City                 string                 `json:"city"`
    // The state for the line's primary place of use.
    State                string                 `json:"state"`
    // The ZIP code for the line's primary place of use.
    Zip                  string                 `json:"zip"`
    // The ZIP+4 for the line's primary place of use.
    Zip4                 *string                `json:"zip4,omitempty"`
    // Either “US” or “USA” for the country of the line's primary place of use.
    Country              string                 `json:"country"`
    // A phone number where the customer can be reached.
    Phone                *string                `json:"phone,omitempty"`
    // A single letter to indicate the customer phone type.
    PhoneType            *string                `json:"phoneType,omitempty"`
    // An email address for the customer.
    EmailAddress         *string                `json:"emailAddress,omitempty"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for Address,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (a Address) String() string {
    return fmt.Sprintf(
    	"Address[AddressLine1=%v, AddressLine2=%v, City=%v, State=%v, Zip=%v, Zip4=%v, Country=%v, Phone=%v, PhoneType=%v, EmailAddress=%v, AdditionalProperties=%v]",
    	a.AddressLine1, a.AddressLine2, a.City, a.State, a.Zip, a.Zip4, a.Country, a.Phone, a.PhoneType, a.EmailAddress, a.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for Address.
// It customizes the JSON marshaling process for Address objects.
func (a Address) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(a.AdditionalProperties,
        "addressLine1", "addressLine2", "city", "state", "zip", "zip4", "country", "phone", "phoneType", "emailAddress"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(a.toMap())
}

// toMap converts the Address object to a map representation for JSON marshaling.
func (a Address) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, a.AdditionalProperties)
    structMap["addressLine1"] = a.AddressLine1
    if a.AddressLine2 != nil {
        structMap["addressLine2"] = a.AddressLine2
    }
    structMap["city"] = a.City
    structMap["state"] = a.State
    structMap["zip"] = a.Zip
    if a.Zip4 != nil {
        structMap["zip4"] = a.Zip4
    }
    structMap["country"] = a.Country
    if a.Phone != nil {
        structMap["phone"] = a.Phone
    }
    if a.PhoneType != nil {
        structMap["phoneType"] = a.PhoneType
    }
    if a.EmailAddress != nil {
        structMap["emailAddress"] = a.EmailAddress
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for Address.
// It customizes the JSON unmarshaling process for Address objects.
func (a *Address) UnmarshalJSON(input []byte) error {
    var temp tempAddress
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "addressLine1", "addressLine2", "city", "state", "zip", "zip4", "country", "phone", "phoneType", "emailAddress")
    if err != nil {
    	return err
    }
    a.AdditionalProperties = additionalProperties
    
    a.AddressLine1 = *temp.AddressLine1
    a.AddressLine2 = temp.AddressLine2
    a.City = *temp.City
    a.State = *temp.State
    a.Zip = *temp.Zip
    a.Zip4 = temp.Zip4
    a.Country = *temp.Country
    a.Phone = temp.Phone
    a.PhoneType = temp.PhoneType
    a.EmailAddress = temp.EmailAddress
    return nil
}

// tempAddress is a temporary struct used for validating the fields of Address.
type tempAddress  struct {
    AddressLine1 *string `json:"addressLine1"`
    AddressLine2 *string `json:"addressLine2,omitempty"`
    City         *string `json:"city"`
    State        *string `json:"state"`
    Zip          *string `json:"zip"`
    Zip4         *string `json:"zip4,omitempty"`
    Country      *string `json:"country"`
    Phone        *string `json:"phone,omitempty"`
    PhoneType    *string `json:"phoneType,omitempty"`
    EmailAddress *string `json:"emailAddress,omitempty"`
}

func (a *tempAddress) validate() error {
    var errs []string
    if a.AddressLine1 == nil {
        errs = append(errs, "required field `addressLine1` is missing for type `Address`")
    }
    if a.City == nil {
        errs = append(errs, "required field `city` is missing for type `Address`")
    }
    if a.State == nil {
        errs = append(errs, "required field `state` is missing for type `Address`")
    }
    if a.Zip == nil {
        errs = append(errs, "required field `zip` is missing for type `Address`")
    }
    if a.Country == nil {
        errs = append(errs, "required field `country` is missing for type `Address`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
