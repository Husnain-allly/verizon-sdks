/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// CreateSubscriptionRequest represents a CreateSubscriptionRequest struct.
// The details of the subscription that you want to create.
type CreateSubscriptionRequest struct {
    // The ID of the authenticating billing account, in the format `{"billingaccountid":"1234567890-12345"}`.
    Accountidentifier    *AccountIdentifier     `json:"accountidentifier,omitempty"`
    // Descriptive information about the subscription.
    Description          *string                `json:"description,omitempty"`
    // Enable or disable the subscription. A disabled subscription will not send any data.
    Disabled             *bool                  `json:"disabled,omitempty"`
    // The address to which any error reports should be delivered.
    Email                *string                `json:"email,omitempty"`
    // String containing a $filter object with a property and value to filter out non-matching events.
    Filter               *string                `json:"filter,omitempty"`
    Billingaccountid     *string                `json:"billingaccountid,omitempty"`
    // The type of event data to send via this subscription. This will be `ts.event` in most cases. Other event types are `ts.event.diagnostics` for device diagnostic data, `ts.event.configuration` for device configuration events, or `ts.event.security`. Note that the device ThingSpace client must support sending specific event types for anything other than `ts.event`.
    Streamkind           *string                `json:"streamkind,omitempty"`
    // The ID of the target resource to be used when dispatching events. The corresponding target should have a “stream” addressscheme.
    Targetid             *string                `json:"targetid,omitempty"`
    // Name of the subscription.
    Name                 *string                `json:"name,omitempty"`
    // Setting this value to `false` prevents the data returned from being aggregated and makes the data easier to parse.
    Allowaggregation     *bool                  `json:"allowaggregation,omitempty"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for CreateSubscriptionRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (c CreateSubscriptionRequest) String() string {
    return fmt.Sprintf(
    	"CreateSubscriptionRequest[Accountidentifier=%v, Description=%v, Disabled=%v, Email=%v, Filter=%v, Billingaccountid=%v, Streamkind=%v, Targetid=%v, Name=%v, Allowaggregation=%v, AdditionalProperties=%v]",
    	c.Accountidentifier, c.Description, c.Disabled, c.Email, c.Filter, c.Billingaccountid, c.Streamkind, c.Targetid, c.Name, c.Allowaggregation, c.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for CreateSubscriptionRequest.
// It customizes the JSON marshaling process for CreateSubscriptionRequest objects.
func (c CreateSubscriptionRequest) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(c.AdditionalProperties,
        "accountidentifier", "description", "disabled", "email", "filter", "billingaccountid", "streamkind", "targetid", "name", "allowaggregation"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(c.toMap())
}

// toMap converts the CreateSubscriptionRequest object to a map representation for JSON marshaling.
func (c CreateSubscriptionRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, c.AdditionalProperties)
    if c.Accountidentifier != nil {
        structMap["accountidentifier"] = c.Accountidentifier.toMap()
    }
    if c.Description != nil {
        structMap["description"] = c.Description
    }
    if c.Disabled != nil {
        structMap["disabled"] = c.Disabled
    }
    if c.Email != nil {
        structMap["email"] = c.Email
    }
    if c.Filter != nil {
        structMap["filter"] = c.Filter
    }
    if c.Billingaccountid != nil {
        structMap["billingaccountid"] = c.Billingaccountid
    }
    if c.Streamkind != nil {
        structMap["streamkind"] = c.Streamkind
    }
    if c.Targetid != nil {
        structMap["targetid"] = c.Targetid
    }
    if c.Name != nil {
        structMap["name"] = c.Name
    }
    if c.Allowaggregation != nil {
        structMap["allowaggregation"] = c.Allowaggregation
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for CreateSubscriptionRequest.
// It customizes the JSON unmarshaling process for CreateSubscriptionRequest objects.
func (c *CreateSubscriptionRequest) UnmarshalJSON(input []byte) error {
    var temp tempCreateSubscriptionRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "accountidentifier", "description", "disabled", "email", "filter", "billingaccountid", "streamkind", "targetid", "name", "allowaggregation")
    if err != nil {
    	return err
    }
    c.AdditionalProperties = additionalProperties
    
    c.Accountidentifier = temp.Accountidentifier
    c.Description = temp.Description
    c.Disabled = temp.Disabled
    c.Email = temp.Email
    c.Filter = temp.Filter
    c.Billingaccountid = temp.Billingaccountid
    c.Streamkind = temp.Streamkind
    c.Targetid = temp.Targetid
    c.Name = temp.Name
    c.Allowaggregation = temp.Allowaggregation
    return nil
}

// tempCreateSubscriptionRequest is a temporary struct used for validating the fields of CreateSubscriptionRequest.
type tempCreateSubscriptionRequest  struct {
    Accountidentifier *AccountIdentifier `json:"accountidentifier,omitempty"`
    Description       *string            `json:"description,omitempty"`
    Disabled          *bool              `json:"disabled,omitempty"`
    Email             *string            `json:"email,omitempty"`
    Filter            *string            `json:"filter,omitempty"`
    Billingaccountid  *string            `json:"billingaccountid,omitempty"`
    Streamkind        *string            `json:"streamkind,omitempty"`
    Targetid          *string            `json:"targetid,omitempty"`
    Name              *string            `json:"name,omitempty"`
    Allowaggregation  *bool              `json:"allowaggregation,omitempty"`
}
