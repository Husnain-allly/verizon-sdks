/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// Region represents a Region struct.
// Information representing a certain geographical or logical area where MEC resources and services are provided.
type Region struct {
    // The unique identifier of the region.
    RegionId    Optional[string] `json:"regionId"`
    // A relevant and identifiable region name.
    Name        Optional[string] `json:"name"`
    // A two-character alpha code for a country, based on ISO 3166-1 alpha-2. This is future functionality, so the value returned is 'null'.
    CountryCode Optional[string] `json:"countryCode"`
    // The metropolitan area or 'City' value.  This is future functionality, so the value returned is 'null'.
    Metro       Optional[string] `json:"metro"`
    // This is a sub-set of 'City' and is similar to 'Zone'. This is future functionality, so the value returned is 'null'.
    Area        Optional[string] `json:"area"`
}

// String implements the fmt.Stringer interface for Region,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (r Region) String() string {
    return fmt.Sprintf(
    	"Region[RegionId=%v, Name=%v, CountryCode=%v, Metro=%v, Area=%v]",
    	r.RegionId, r.Name, r.CountryCode, r.Metro, r.Area)
}

// MarshalJSON implements the json.Marshaler interface for Region.
// It customizes the JSON marshaling process for Region objects.
func (r Region) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(r.toMap())
}

// toMap converts the Region object to a map representation for JSON marshaling.
func (r Region) toMap() map[string]any {
    structMap := make(map[string]any)
    if r.RegionId.IsValueSet() {
        if r.RegionId.Value() != nil {
            structMap["regionId"] = r.RegionId.Value()
        } else {
            structMap["regionId"] = nil
        }
    }
    if r.Name.IsValueSet() {
        if r.Name.Value() != nil {
            structMap["name"] = r.Name.Value()
        } else {
            structMap["name"] = nil
        }
    }
    if r.CountryCode.IsValueSet() {
        if r.CountryCode.Value() != nil {
            structMap["countryCode"] = r.CountryCode.Value()
        } else {
            structMap["countryCode"] = nil
        }
    }
    if r.Metro.IsValueSet() {
        if r.Metro.Value() != nil {
            structMap["metro"] = r.Metro.Value()
        } else {
            structMap["metro"] = nil
        }
    }
    if r.Area.IsValueSet() {
        if r.Area.Value() != nil {
            structMap["area"] = r.Area.Value()
        } else {
            structMap["area"] = nil
        }
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for Region.
// It customizes the JSON unmarshaling process for Region objects.
func (r *Region) UnmarshalJSON(input []byte) error {
    var temp tempRegion
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    
    r.RegionId = temp.RegionId
    r.Name = temp.Name
    r.CountryCode = temp.CountryCode
    r.Metro = temp.Metro
    r.Area = temp.Area
    return nil
}

// tempRegion is a temporary struct used for validating the fields of Region.
type tempRegion  struct {
    RegionId    Optional[string] `json:"regionId"`
    Name        Optional[string] `json:"name"`
    CountryCode Optional[string] `json:"countryCode"`
    Metro       Optional[string] `json:"metro"`
    Area        Optional[string] `json:"area"`
}
