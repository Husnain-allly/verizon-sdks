/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
)

// Geometry represents a Geometry struct.
type Geometry struct {
    value             any
    isLineString      bool
    isPolygon         bool
    isMultiLineString bool
    isMultiPolygon    bool
}

// String implements the fmt.Stringer interface for Geometry,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (g Geometry) String() string {
    return fmt.Sprintf("%v", g.value)
}

// MarshalJSON implements the json.Marshaler interface for Geometry.
// It customizes the JSON marshaling process for Geometry objects.
func (g Geometry) MarshalJSON() (
    []byte,
    error) {
    if g.value == nil {
        return nil, errors.New("No underlying type is set. Please use any of the `models.GeometryContainer.From*` functions to initialize the Geometry object.")
    }
    return json.Marshal(g.toMap())
}

// toMap converts the Geometry object to a map representation for JSON marshaling.
func (g *Geometry) toMap() any {
    switch obj := g.value.(type) {
    case *LineString:
        return obj.toMap()
    case *Polygon:
        return obj.toMap()
    case *MultiLineString:
        return obj.toMap()
    case *MultiPolygon:
        return obj.toMap()
    }
    return nil
}

// UnmarshalJSON implements the json.Unmarshaler interface for Geometry.
// It customizes the JSON unmarshaling process for Geometry objects.
func (g *Geometry) UnmarshalJSON(input []byte) error {
    result, err := UnmarshallOneOfWithDiscriminator(input, "type",
        NewTypeHolderDiscriminator(&LineString{}, false, &g.isLineString, "LineString"),
        NewTypeHolderDiscriminator(&Polygon{}, false, &g.isPolygon, "Polygon"),
        NewTypeHolderDiscriminator(&MultiLineString{}, false, &g.isMultiLineString, "MultiLineString"),
        NewTypeHolderDiscriminator(&MultiPolygon{}, false, &g.isMultiPolygon, "MultiPolygon"),
    )
    
    g.value = result
    return err
}

func (g *Geometry) AsLineString() (
    *LineString,
    bool) {
    if !g.isLineString {
        return nil, false
    }
    return g.value.(*LineString), true
}

func (g *Geometry) AsPolygon() (
    *Polygon,
    bool) {
    if !g.isPolygon {
        return nil, false
    }
    return g.value.(*Polygon), true
}

func (g *Geometry) AsMultiLineString() (
    *MultiLineString,
    bool) {
    if !g.isMultiLineString {
        return nil, false
    }
    return g.value.(*MultiLineString), true
}

func (g *Geometry) AsMultiPolygon() (
    *MultiPolygon,
    bool) {
    if !g.isMultiPolygon {
        return nil, false
    }
    return g.value.(*MultiPolygon), true
}

// internalGeometry represents a geometry struct.
type internalGeometry struct {}

var GeometryContainer internalGeometry

// The internalGeometry instance, wrapping the provided LineString value.
func (g *internalGeometry) FromLineString(val LineString) Geometry {
    return Geometry{value: &val}
}

// The internalGeometry instance, wrapping the provided Polygon value.
func (g *internalGeometry) FromPolygon(val Polygon) Geometry {
    return Geometry{value: &val}
}

// The internalGeometry instance, wrapping the provided MultiLineString value.
func (g *internalGeometry) FromMultiLineString(val MultiLineString) Geometry {
    return Geometry{value: &val}
}

// The internalGeometry instance, wrapping the provided MultiPolygon value.
func (g *internalGeometry) FromMultiPolygon(val MultiPolygon) Geometry {
    return Geometry{value: &val}
}
