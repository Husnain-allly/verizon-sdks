/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "strings"
)

// DataFrame represents a DataFrame struct.
// The data frame allows sending various advisory and road sign types of information to equipped devices.
type DataFrame struct {
    // Always set to 0 and carries no meaning. Legacy field maintained for backward compatibility.
    NotUsed      int                `json:"notUsed"`
    // The frameType data element provides the type of message to follow in the rest of the message frame structure. The following frame types are supported:
    // - unknown
    // - advisory
    // - roadSignage
    // - commercialSignage
    FrameType    FrameType          `json:"frameType"`
    MsgId        DataFrameMsgId     `json:"msgId"`
    // The V2X year consists of integer values from zero to 4095 representing the year according to the Gregorian calendar date system. The value of zero shall represent an unknown value.
    StartYear    *int               `json:"startYear,omitempty"`
    // Start time expresses the number of elapsed minutes of the current year in the time system being used (typically UTC time). The value 527040 shall be used for invalid.
    StartTime    int                `json:"startTime"`
    // The duration, in units of whole minutes, that a object persists for. A value of 32000 means that the object persists forever. The range 0..32000 provides for about 22.2 days of maximum duration.
    DurationTime int                `json:"durationTime"`
    // The relative importance of the sign, on a scale from zero (least important) to seven (most important).
    Priority     int                `json:"priority"`
    // Always set to 0 and carries no meaning. Legacy field maintained for backward compatibility.
    NotUsed1     int                `json:"notUsed1"`
    // The data frame is used to support the cross-cutting need in many V2X messages to describe arbitrary spatial areas (polygons, boundary lines, and other basic shapes) required by various message types in a small message size. This data frame can describe a complex path or region of arbitrary size using either one of the two supported node offset methods (XY offsets or LL offsets) or using simple geometric projections.
    Regions      []GeographicalPath `json:"regions"`
    // Always set to 0 and carries no meaning. Legacy field maintained for backward compatibility.
    NotUsed2     int                `json:"notUsed2"`
    // Always set to 0 and carries no meaning. Legacy field maintained for backward compatibility.
    NotUsed3     int                `json:"notUsed3"`
    Content      DataFrameContent   `json:"content"`
}

// String implements the fmt.Stringer interface for DataFrame,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (d DataFrame) String() string {
    return fmt.Sprintf(
    	"DataFrame[NotUsed=%v, FrameType=%v, MsgId=%v, StartYear=%v, StartTime=%v, DurationTime=%v, Priority=%v, NotUsed1=%v, Regions=%v, NotUsed2=%v, NotUsed3=%v, Content=%v]",
    	d.NotUsed, d.FrameType, d.MsgId, d.StartYear, d.StartTime, d.DurationTime, d.Priority, d.NotUsed1, d.Regions, d.NotUsed2, d.NotUsed3, d.Content)
}

// MarshalJSON implements the json.Marshaler interface for DataFrame.
// It customizes the JSON marshaling process for DataFrame objects.
func (d DataFrame) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(d.toMap())
}

// toMap converts the DataFrame object to a map representation for JSON marshaling.
func (d DataFrame) toMap() map[string]any {
    structMap := make(map[string]any)
    structMap["notUsed"] = d.NotUsed
    structMap["frameType"] = d.FrameType
    structMap["msgId"] = d.MsgId.toMap()
    if d.StartYear != nil {
        structMap["startYear"] = d.StartYear
    }
    structMap["startTime"] = d.StartTime
    structMap["durationTime"] = d.DurationTime
    structMap["priority"] = d.Priority
    structMap["notUsed1"] = d.NotUsed1
    structMap["regions"] = d.Regions
    structMap["notUsed2"] = d.NotUsed2
    structMap["notUsed3"] = d.NotUsed3
    structMap["content"] = d.Content.toMap()
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for DataFrame.
// It customizes the JSON unmarshaling process for DataFrame objects.
func (d *DataFrame) UnmarshalJSON(input []byte) error {
    var temp tempDataFrame
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    
    d.NotUsed = *temp.NotUsed
    d.FrameType = *temp.FrameType
    d.MsgId = *temp.MsgId
    d.StartYear = temp.StartYear
    d.StartTime = *temp.StartTime
    d.DurationTime = *temp.DurationTime
    d.Priority = *temp.Priority
    d.NotUsed1 = *temp.NotUsed1
    d.Regions = *temp.Regions
    d.NotUsed2 = *temp.NotUsed2
    d.NotUsed3 = *temp.NotUsed3
    d.Content = *temp.Content
    return nil
}

// tempDataFrame is a temporary struct used for validating the fields of DataFrame.
type tempDataFrame  struct {
    NotUsed      *int                `json:"notUsed"`
    FrameType    *FrameType          `json:"frameType"`
    MsgId        *DataFrameMsgId     `json:"msgId"`
    StartYear    *int                `json:"startYear,omitempty"`
    StartTime    *int                `json:"startTime"`
    DurationTime *int                `json:"durationTime"`
    Priority     *int                `json:"priority"`
    NotUsed1     *int                `json:"notUsed1"`
    Regions      *[]GeographicalPath `json:"regions"`
    NotUsed2     *int                `json:"notUsed2"`
    NotUsed3     *int                `json:"notUsed3"`
    Content      *DataFrameContent   `json:"content"`
}

func (d *tempDataFrame) validate() error {
    var errs []string
    if d.NotUsed == nil {
        errs = append(errs, "required field `notUsed` is missing for type `DataFrame`")
    }
    if d.FrameType == nil {
        errs = append(errs, "required field `frameType` is missing for type `DataFrame`")
    }
    if d.MsgId == nil {
        errs = append(errs, "required field `msgId` is missing for type `DataFrame`")
    }
    if d.StartTime == nil {
        errs = append(errs, "required field `startTime` is missing for type `DataFrame`")
    }
    if d.DurationTime == nil {
        errs = append(errs, "required field `durationTime` is missing for type `DataFrame`")
    }
    if d.Priority == nil {
        errs = append(errs, "required field `priority` is missing for type `DataFrame`")
    }
    if d.NotUsed1 == nil {
        errs = append(errs, "required field `notUsed1` is missing for type `DataFrame`")
    }
    if d.Regions == nil {
        errs = append(errs, "required field `regions` is missing for type `DataFrame`")
    }
    if d.NotUsed2 == nil {
        errs = append(errs, "required field `notUsed2` is missing for type `DataFrame`")
    }
    if d.NotUsed3 == nil {
        errs = append(errs, "required field `notUsed3` is missing for type `DataFrame`")
    }
    if d.Content == nil {
        errs = append(errs, "required field `content` is missing for type `DataFrame`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
