# -*- coding: utf-8 -*-

"""
verizon

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from verizon.api_helper import APIHelper
from verizon.models.distribution_schedule import DistributionSchedule
from verizon.models.generic import Generic
from verizon.models.road_user_types import RoadUserTypes
from verizon.models.trigger_condition import TriggerCondition


class Message(object):

    """Implementation of the 'Message' model.

    Attributes:
        is_private (bool): Defines whether the message is private or public.
            Private messages are published under the Vendor ID defined in the
            configuration and only visible to devices of selected vendors.
            Public messages are published under the Public vendor and are
            visible to all the users.
        road_user_type (List[RoadUserTypes]): Type of the Road User.
        trigger_conditions (List[TriggerCondition]): Trigger conditions that
            define on which road user action the message will be sent. If
            multiple Trigger Conditions are defined any of them will trigger
            the message.
        limits (List[SpeedItem | HeadingItem] | None): List of limitations.
            These limitations can be used for making the trigger condition
            more precise by defining speed and motion direction requirements
            to be met before the messages are sent out.
        distribution_type (List[DistributionTypes]): Type of the distribution.
        distribution_schedule (DistributionSchedule): The distribution
            schedule parameters for broadcast messages.
        generic (Generic): Custom message which is defined by the user and can
            support "any" message type or format.  **Note:** ETX prefers the
            j2735 or the j2735_gr encoding and only vendor specific message
            types are allowed to be published in different message formats.
        additional_properties (Dict[str, Any]): The additional properties for
            the model.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "is_private": 'isPrivate',
        "road_user_type": 'roadUserType',
        "trigger_conditions": 'triggerConditions',
        "generic": 'generic',
        "limits": 'limits',
        "distribution_type": 'distributionType',
        "distribution_schedule": 'distributionSchedule'
    }

    _optionals = [
        'limits',
        'distribution_type',
        'distribution_schedule',
    ]

    def __init__(self,
                 is_private=None,
                 road_user_type=None,
                 trigger_conditions=None,
                 generic=None,
                 limits=APIHelper.SKIP,
                 distribution_type=APIHelper.SKIP,
                 distribution_schedule=APIHelper.SKIP,
                 additional_properties=None):
        """Constructor for the Message class"""

        # Initialize members of the class
        self.is_private = is_private 
        self.road_user_type = road_user_type 
        self.trigger_conditions = trigger_conditions 
        if limits is not APIHelper.SKIP:
            self.limits = limits 
        if distribution_type is not APIHelper.SKIP:
            self.distribution_type = distribution_type 
        if distribution_schedule is not APIHelper.SKIP:
            self.distribution_schedule = distribution_schedule 
        self.generic = generic 

        # Add additional model properties to the instance
        if additional_properties is None:
            additional_properties = {}
        self.additional_properties = additional_properties

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        from verizon.utilities.union_type_lookup import UnionTypeLookUp

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        is_private = dictionary.get("isPrivate") if "isPrivate" in dictionary.keys() else None
        road_user_type = dictionary.get("roadUserType") if dictionary.get("roadUserType") else None
        trigger_conditions = dictionary.get("triggerConditions") if dictionary.get("triggerConditions") else None
        generic = Generic.from_dictionary(dictionary.get('generic')) if dictionary.get('generic') else None
        limits = APIHelper.deserialize_union_type(UnionTypeLookUp.get('Limits'), dictionary.get('limits'), False) if dictionary.get('limits') is not None else APIHelper.SKIP
        distribution_type = dictionary.get("distributionType") if dictionary.get("distributionType") else APIHelper.SKIP
        distribution_schedule = DistributionSchedule.from_dictionary(dictionary.get('distributionSchedule')) if 'distributionSchedule' in dictionary.keys() else APIHelper.SKIP
        additional_properties = APIHelper.get_additional_properties(
            dictionary={k: v for k, v in dictionary.items() if k not in cls._names.values()},
            unboxing_function=lambda value: value)
        # Return an object of this model
        return cls(is_private,
                   road_user_type,
                   trigger_conditions,
                   generic,
                   limits,
                   distribution_type,
                   distribution_schedule,
                   additional_properties)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(value=dictionary.is_private,
                                           type_callable=lambda value: isinstance(value, bool)) \
                and APIHelper.is_valid_type(value=dictionary.road_user_type,
                                            type_callable=lambda value: RoadUserTypes.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.trigger_conditions,
                                            type_callable=lambda value: TriggerCondition.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.generic,
                                            type_callable=lambda value: Generic.validate(value),
                                            is_model_dict=True)

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(value=dictionary.get('isPrivate'),
                                       type_callable=lambda value: isinstance(value, bool)) \
            and APIHelper.is_valid_type(value=dictionary.get('roadUserType'),
                                        type_callable=lambda value: RoadUserTypes.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('triggerConditions'),
                                        type_callable=lambda value: TriggerCondition.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('generic'),
                                        type_callable=lambda value: Generic.validate(value),
                                        is_model_dict=True)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'is_private={self.is_private!r}, '
                f'road_user_type={self.road_user_type!r}, '
                f'trigger_conditions={self.trigger_conditions!r}, '
                f'limits={(self.limits if hasattr(self, "limits") else None)!r}, '
                f'distribution_type={(self.distribution_type if hasattr(self, "distribution_type") else None)!r}, '
                f'distribution_schedule={(self.distribution_schedule if hasattr(self, "distribution_schedule") else None)!r}, '
                f'generic={self.generic!r}, '
                f'additional_properties={self.additional_properties!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'is_private={self.is_private!s}, '
                f'road_user_type={self.road_user_type!s}, '
                f'trigger_conditions={self.trigger_conditions!s}, '
                f'limits={(self.limits if hasattr(self, "limits") else None)!s}, '
                f'distribution_type={(self.distribution_type if hasattr(self, "distribution_type") else None)!s}, '
                f'distribution_schedule={(self.distribution_schedule if hasattr(self, "distribution_schedule") else None)!s}, '
                f'generic={self.generic!s}, '
                f'additional_properties={self.additional_properties!s})')
