/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
    "log"
    "time"
)

// UploadConfigurationFilesResponse represents a UploadConfigurationFilesResponse struct.
type UploadConfigurationFilesResponse struct {
    // The name of the file you are upgrading to.
    FileName             *string                `json:"fileName,omitempty"`
    // The version of the file you are upgrading to.
    FileVersion          *string                `json:"fileVersion,omitempty"`
    // Software launch date.
    LaunchDate           *time.Time             `json:"launchDate,omitempty"`
    // Software release note.
    ReleaseNote          *string                `json:"releaseNote,omitempty"`
    // Software applicable device model.
    Model                *string                `json:"model,omitempty"`
    // Software applicable device make.
    Make                 *string                `json:"make,omitempty"`
    // LWM2M, OMD-DM or HTTP.
    DistributionType     *string                `json:"distributionType,omitempty"`
    // The platform (Android, iOS, etc.) that the software can be applied to.
    DevicePlatformId     *string                `json:"devicePlatformId,omitempty"`
    // Local target path on the device.
    LocalTargetPath      *string                `json:"localTargetPath,omitempty"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for UploadConfigurationFilesResponse,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (u UploadConfigurationFilesResponse) String() string {
    return fmt.Sprintf(
    	"UploadConfigurationFilesResponse[FileName=%v, FileVersion=%v, LaunchDate=%v, ReleaseNote=%v, Model=%v, Make=%v, DistributionType=%v, DevicePlatformId=%v, LocalTargetPath=%v, AdditionalProperties=%v]",
    	u.FileName, u.FileVersion, u.LaunchDate, u.ReleaseNote, u.Model, u.Make, u.DistributionType, u.DevicePlatformId, u.LocalTargetPath, u.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for UploadConfigurationFilesResponse.
// It customizes the JSON marshaling process for UploadConfigurationFilesResponse objects.
func (u UploadConfigurationFilesResponse) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(u.AdditionalProperties,
        "fileName", "fileVersion", "launchDate", "releaseNote", "model", "make", "distributionType", "devicePlatformId", "localTargetPath"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(u.toMap())
}

// toMap converts the UploadConfigurationFilesResponse object to a map representation for JSON marshaling.
func (u UploadConfigurationFilesResponse) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, u.AdditionalProperties)
    if u.FileName != nil {
        structMap["fileName"] = u.FileName
    }
    if u.FileVersion != nil {
        structMap["fileVersion"] = u.FileVersion
    }
    if u.LaunchDate != nil {
        structMap["launchDate"] = u.LaunchDate.Format(DEFAULT_DATE)
    }
    if u.ReleaseNote != nil {
        structMap["releaseNote"] = u.ReleaseNote
    }
    if u.Model != nil {
        structMap["model"] = u.Model
    }
    if u.Make != nil {
        structMap["make"] = u.Make
    }
    if u.DistributionType != nil {
        structMap["distributionType"] = u.DistributionType
    }
    if u.DevicePlatformId != nil {
        structMap["devicePlatformId"] = u.DevicePlatformId
    }
    if u.LocalTargetPath != nil {
        structMap["localTargetPath"] = u.LocalTargetPath
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for UploadConfigurationFilesResponse.
// It customizes the JSON unmarshaling process for UploadConfigurationFilesResponse objects.
func (u *UploadConfigurationFilesResponse) UnmarshalJSON(input []byte) error {
    var temp tempUploadConfigurationFilesResponse
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "fileName", "fileVersion", "launchDate", "releaseNote", "model", "make", "distributionType", "devicePlatformId", "localTargetPath")
    if err != nil {
    	return err
    }
    u.AdditionalProperties = additionalProperties
    
    u.FileName = temp.FileName
    u.FileVersion = temp.FileVersion
    if temp.LaunchDate != nil {
        LaunchDateVal, err := time.Parse(DEFAULT_DATE, *temp.LaunchDate)
        if err != nil {
            log.Fatalf("Cannot Parse launchDate as % s format.", DEFAULT_DATE)
        }
        u.LaunchDate = &LaunchDateVal
    }
    u.ReleaseNote = temp.ReleaseNote
    u.Model = temp.Model
    u.Make = temp.Make
    u.DistributionType = temp.DistributionType
    u.DevicePlatformId = temp.DevicePlatformId
    u.LocalTargetPath = temp.LocalTargetPath
    return nil
}

// tempUploadConfigurationFilesResponse is a temporary struct used for validating the fields of UploadConfigurationFilesResponse.
type tempUploadConfigurationFilesResponse  struct {
    FileName         *string `json:"fileName,omitempty"`
    FileVersion      *string `json:"fileVersion,omitempty"`
    LaunchDate       *string `json:"launchDate,omitempty"`
    ReleaseNote      *string `json:"releaseNote,omitempty"`
    Model            *string `json:"model,omitempty"`
    Make             *string `json:"make,omitempty"`
    DistributionType *string `json:"distributionType,omitempty"`
    DevicePlatformId *string `json:"devicePlatformId,omitempty"`
    LocalTargetPath  *string `json:"localTargetPath,omitempty"`
}
