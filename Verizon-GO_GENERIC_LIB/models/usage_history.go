/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
    "log"
    "time"
)

// UsageHistory represents a UsageHistory struct.
type UsageHistory struct {
    BytesUsed            *int                   `json:"bytesUsed,omitempty"`
    Serviceplan          *string                `json:"serviceplan,omitempty"`
    SmsUsed              *int                   `json:"smsUsed,omitempty"`
    MoSms                *int                   `json:"moSMS,omitempty"`
    MtSms                *int                   `json:"mtSMS,omitempty"`
    Source               *string                `json:"source,omitempty"`
    EventDateTime        *time.Time             `json:"eventDateTime,omitempty"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for UsageHistory,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (u UsageHistory) String() string {
    return fmt.Sprintf(
    	"UsageHistory[BytesUsed=%v, Serviceplan=%v, SmsUsed=%v, MoSms=%v, MtSms=%v, Source=%v, EventDateTime=%v, AdditionalProperties=%v]",
    	u.BytesUsed, u.Serviceplan, u.SmsUsed, u.MoSms, u.MtSms, u.Source, u.EventDateTime, u.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for UsageHistory.
// It customizes the JSON marshaling process for UsageHistory objects.
func (u UsageHistory) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(u.AdditionalProperties,
        "bytesUsed", "serviceplan", "smsUsed", "moSMS", "mtSMS", "source", "eventDateTime"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(u.toMap())
}

// toMap converts the UsageHistory object to a map representation for JSON marshaling.
func (u UsageHistory) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, u.AdditionalProperties)
    if u.BytesUsed != nil {
        structMap["bytesUsed"] = u.BytesUsed
    }
    if u.Serviceplan != nil {
        structMap["serviceplan"] = u.Serviceplan
    }
    if u.SmsUsed != nil {
        structMap["smsUsed"] = u.SmsUsed
    }
    if u.MoSms != nil {
        structMap["moSMS"] = u.MoSms
    }
    if u.MtSms != nil {
        structMap["mtSMS"] = u.MtSms
    }
    if u.Source != nil {
        structMap["source"] = u.Source
    }
    if u.EventDateTime != nil {
        structMap["eventDateTime"] = u.EventDateTime.Format(time.RFC3339)
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for UsageHistory.
// It customizes the JSON unmarshaling process for UsageHistory objects.
func (u *UsageHistory) UnmarshalJSON(input []byte) error {
    var temp tempUsageHistory
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "bytesUsed", "serviceplan", "smsUsed", "moSMS", "mtSMS", "source", "eventDateTime")
    if err != nil {
    	return err
    }
    u.AdditionalProperties = additionalProperties
    
    u.BytesUsed = temp.BytesUsed
    u.Serviceplan = temp.Serviceplan
    u.SmsUsed = temp.SmsUsed
    u.MoSms = temp.MoSms
    u.MtSms = temp.MtSms
    u.Source = temp.Source
    if temp.EventDateTime != nil {
        EventDateTimeVal, err := time.Parse(time.RFC3339, *temp.EventDateTime)
        if err != nil {
            log.Fatalf("Cannot Parse eventDateTime as % s format.", time.RFC3339)
        }
        u.EventDateTime = &EventDateTimeVal
    }
    return nil
}

// tempUsageHistory is a temporary struct used for validating the fields of UsageHistory.
type tempUsageHistory  struct {
    BytesUsed     *int    `json:"bytesUsed,omitempty"`
    Serviceplan   *string `json:"serviceplan,omitempty"`
    SmsUsed       *int    `json:"smsUsed,omitempty"`
    MoSms         *int    `json:"moSMS,omitempty"`
    MtSms         *int    `json:"mtSMS,omitempty"`
    Source        *string `json:"source,omitempty"`
    EventDateTime *string `json:"eventDateTime,omitempty"`
}
