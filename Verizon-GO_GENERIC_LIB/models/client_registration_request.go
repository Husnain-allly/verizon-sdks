/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "github.com/google/uuid"
    "strings"
)

// ClientRegistrationRequest represents a ClientRegistrationRequest struct.
// Request for /clients/registration endpoint. It requires the Client Type, Subtype and Vendor to be defined.
type ClientRegistrationRequest struct {
    // The type of the client that is to be registered. This is one of the major traffic participant groups considered in V2X communication. The system uses this value to define which topics the client will be able to publish and subscribe to.
    // Values:
    // - **Vehicle** - Vehicle with an enclosure around the passengers. (Subtypes: PassengerCar, Truck, Bus, EmergencyVehicle, SchoolBus, MaintenanceVehicle)
    // - **VulnerableRoadUser** - Traffic participants without a protecting enclosure. (Subtypes: Motorcycle, Bicycle, Pedestrian, Scooter)
    // - **TrafficLightController** - A Traffic light controller system. (Subtypes: NA)
    // - **InfrastructureSensor** - Sensors that are deployed in the infrastructure. (Subtypes: RoadSideUnit, Camera, Lidar, Radar, InductiveLoop, MagneticSensor)
    // - **OnboardSensor** - Sensors that are onboard on a vehicle(Subtypes: Camera, Lidar, Radar)
    // - **Software** - A software system or application. (Subtypes: Platform, Application, NA)
    ClientType    EtxClientType `json:"ClientType"`
    // The subtype or subgroup of the client type. This further specifies the client type. For example it will specify if the client is a passenger car or a truck. See the ClientType description for the supported Subtypes for each client type.
    ClientSubtype ClientSubtype `json:"ClientSubtype"`
    // The ID the vendor wants its devices to be registered under. E.g. Verizon, GM, Ford, etc.
    VendorId      string        `json:"VendorID"`
    // The generated ID (UUID v4) for the device. It can be used as:
    // - the MQTT Client ID when connecting to the Message Exchange system
    // - a parameter when asking for the connection endpoint
    // - a parameter when finishing the device registration
    // - a parameter when unregistering the device
    DeviceId      *uuid.UUID    `json:"DeviceID,omitempty"`
    // The IMEI number of the device.
    Imei          *string       `json:"IMEI,omitempty"`
    // The ICCID number of the device.
    Iccid         *string       `json:"ICCID,omitempty"`
}

// String implements the fmt.Stringer interface for ClientRegistrationRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (c ClientRegistrationRequest) String() string {
    return fmt.Sprintf(
    	"ClientRegistrationRequest[ClientType=%v, ClientSubtype=%v, VendorId=%v, DeviceId=%v, Imei=%v, Iccid=%v]",
    	c.ClientType, c.ClientSubtype, c.VendorId, c.DeviceId, c.Imei, c.Iccid)
}

// MarshalJSON implements the json.Marshaler interface for ClientRegistrationRequest.
// It customizes the JSON marshaling process for ClientRegistrationRequest objects.
func (c ClientRegistrationRequest) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(c.toMap())
}

// toMap converts the ClientRegistrationRequest object to a map representation for JSON marshaling.
func (c ClientRegistrationRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    structMap["ClientType"] = c.ClientType
    structMap["ClientSubtype"] = c.ClientSubtype
    structMap["VendorID"] = c.VendorId
    if c.DeviceId != nil {
        structMap["DeviceID"] = c.DeviceId
    }
    if c.Imei != nil {
        structMap["IMEI"] = c.Imei
    }
    if c.Iccid != nil {
        structMap["ICCID"] = c.Iccid
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for ClientRegistrationRequest.
// It customizes the JSON unmarshaling process for ClientRegistrationRequest objects.
func (c *ClientRegistrationRequest) UnmarshalJSON(input []byte) error {
    var temp tempClientRegistrationRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    
    c.ClientType = *temp.ClientType
    c.ClientSubtype = *temp.ClientSubtype
    c.VendorId = *temp.VendorId
    c.DeviceId = temp.DeviceId
    c.Imei = temp.Imei
    c.Iccid = temp.Iccid
    return nil
}

// tempClientRegistrationRequest is a temporary struct used for validating the fields of ClientRegistrationRequest.
type tempClientRegistrationRequest  struct {
    ClientType    *EtxClientType `json:"ClientType"`
    ClientSubtype *ClientSubtype `json:"ClientSubtype"`
    VendorId      *string        `json:"VendorID"`
    DeviceId      *uuid.UUID     `json:"DeviceID,omitempty"`
    Imei          *string        `json:"IMEI,omitempty"`
    Iccid         *string        `json:"ICCID,omitempty"`
}

func (c *tempClientRegistrationRequest) validate() error {
    var errs []string
    if c.ClientType == nil {
        errs = append(errs, "required field `ClientType` is missing for type `ClientRegistrationRequest`")
    }
    if c.ClientSubtype == nil {
        errs = append(errs, "required field `ClientSubtype` is missing for type `ClientRegistrationRequest`")
    }
    if c.VendorId == nil {
        errs = append(errs, "required field `VendorID` is missing for type `ClientRegistrationRequest`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
