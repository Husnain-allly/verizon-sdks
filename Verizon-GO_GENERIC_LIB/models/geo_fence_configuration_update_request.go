/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// GeoFenceConfigurationUpdateRequest represents a GeoFenceConfigurationUpdateRequest struct.
// Request for /api/v1/application/configurations/geofence PUT endpoint. It requires at least one of vendorId, name, description, geofence, messages and isActive fields to be populated.
type GeoFenceConfigurationUpdateRequest struct {
    // Name of the configuration.
    Name        *string       `json:"name,omitempty"`
    // Description of the configuration.
    Description *string       `json:"description,omitempty"`
    // The GeoJSON representation of geofence. Geofence supports the following geometry types: LineString, Polygon, MultiLineString, and MultiPolygon. The system only supports a single Feature in the FeatureCollection, so only one Line, Polygon, MultiLine or MultiPolygon can be defined within one Geofencing configuration.
    GeoFence    *EtxGeofence  `json:"geoFence,omitempty"`
    // List of predefined messages that belongs to the geofence. These are the messages that are sent out by the system when the Trigger Condition for the message is met.
    Messages    []interface{} `json:"messages,omitempty"`
    IsActive    *bool         `json:"isActive,omitempty"`
}

// String implements the fmt.Stringer interface for GeoFenceConfigurationUpdateRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (g GeoFenceConfigurationUpdateRequest) String() string {
    return fmt.Sprintf(
    	"GeoFenceConfigurationUpdateRequest[Name=%v, Description=%v, GeoFence=%v, Messages=%v, IsActive=%v]",
    	g.Name, g.Description, g.GeoFence, g.Messages, g.IsActive)
}

// MarshalJSON implements the json.Marshaler interface for GeoFenceConfigurationUpdateRequest.
// It customizes the JSON marshaling process for GeoFenceConfigurationUpdateRequest objects.
func (g GeoFenceConfigurationUpdateRequest) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(g.toMap())
}

// toMap converts the GeoFenceConfigurationUpdateRequest object to a map representation for JSON marshaling.
func (g GeoFenceConfigurationUpdateRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    if g.Name != nil {
        structMap["name"] = g.Name
    }
    if g.Description != nil {
        structMap["description"] = g.Description
    }
    if g.GeoFence != nil {
        structMap["geoFence"] = g.GeoFence.toMap()
    }
    if g.Messages != nil {
        structMap["messages"] = g.Messages
    }
    if g.IsActive != nil {
        structMap["isActive"] = g.IsActive
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for GeoFenceConfigurationUpdateRequest.
// It customizes the JSON unmarshaling process for GeoFenceConfigurationUpdateRequest objects.
func (g *GeoFenceConfigurationUpdateRequest) UnmarshalJSON(input []byte) error {
    var temp tempGeoFenceConfigurationUpdateRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    
    g.Name = temp.Name
    g.Description = temp.Description
    g.GeoFence = temp.GeoFence
    g.Messages = temp.Messages
    g.IsActive = temp.IsActive
    return nil
}

// tempGeoFenceConfigurationUpdateRequest is a temporary struct used for validating the fields of GeoFenceConfigurationUpdateRequest.
type tempGeoFenceConfigurationUpdateRequest  struct {
    Name        *string       `json:"name,omitempty"`
    Description *string       `json:"description,omitempty"`
    GeoFence    *EtxGeofence  `json:"geoFence,omitempty"`
    Messages    []interface{} `json:"messages,omitempty"`
    IsActive    *bool         `json:"isActive,omitempty"`
}
