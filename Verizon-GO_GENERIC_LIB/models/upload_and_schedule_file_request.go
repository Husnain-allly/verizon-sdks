/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// UploadAndScheduleFileRequest represents a UploadAndScheduleFileRequest struct.
type UploadAndScheduleFileRequest struct {
    // The campaign name.
    CampaignName           *string                `json:"campaignName,omitempty"`
    // The name of the file you are upgrading to.
    FileName               *string                `json:"fileName,omitempty"`
    // The version of the file you are upgrading to.
    FileVersion            *string                `json:"fileVersion,omitempty"`
    // Valid values
    DistributionType       *string                `json:"distributionType,omitempty"`
    // Campaign start date.
    StartDate              *string                `json:"startDate,omitempty"`
    // Campaign end date.
    EndDate                *string                `json:"endDate,omitempty"`
    // Specifies the starting date the client should download the package. If null, client downloads as soon as possible.
    DownloadAfterDate      *string                `json:"downloadAfterDate,omitempty"`
    // List of allowed download time windows.
    DownloadTimeWindowList []DownloadTimeWindow   `json:"downloadTimeWindowList,omitempty"`
    // The date after which you install the package. If null, install as soon as possible.
    InstallAfterDate       *string                `json:"installAfterDate,omitempty"`
    // List of allowed install time windows.
    InstallTimeWindowList  []DownloadTimeWindow   `json:"installTimeWindowList,omitempty"`
    // Device IMEI list.
    DeviceList             []string               `json:"deviceList,omitempty"`
    AdditionalProperties   map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for UploadAndScheduleFileRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (u UploadAndScheduleFileRequest) String() string {
    return fmt.Sprintf(
    	"UploadAndScheduleFileRequest[CampaignName=%v, FileName=%v, FileVersion=%v, DistributionType=%v, StartDate=%v, EndDate=%v, DownloadAfterDate=%v, DownloadTimeWindowList=%v, InstallAfterDate=%v, InstallTimeWindowList=%v, DeviceList=%v, AdditionalProperties=%v]",
    	u.CampaignName, u.FileName, u.FileVersion, u.DistributionType, u.StartDate, u.EndDate, u.DownloadAfterDate, u.DownloadTimeWindowList, u.InstallAfterDate, u.InstallTimeWindowList, u.DeviceList, u.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for UploadAndScheduleFileRequest.
// It customizes the JSON marshaling process for UploadAndScheduleFileRequest objects.
func (u UploadAndScheduleFileRequest) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(u.AdditionalProperties,
        "campaignName", "fileName", "fileVersion", "distributionType", "startDate", "endDate", "downloadAfterDate", "downloadTimeWindowList", "installAfterDate", "installTimeWindowList", "deviceList"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(u.toMap())
}

// toMap converts the UploadAndScheduleFileRequest object to a map representation for JSON marshaling.
func (u UploadAndScheduleFileRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, u.AdditionalProperties)
    if u.CampaignName != nil {
        structMap["campaignName"] = u.CampaignName
    }
    if u.FileName != nil {
        structMap["fileName"] = u.FileName
    }
    if u.FileVersion != nil {
        structMap["fileVersion"] = u.FileVersion
    }
    if u.DistributionType != nil {
        structMap["distributionType"] = u.DistributionType
    }
    if u.StartDate != nil {
        structMap["startDate"] = u.StartDate
    }
    if u.EndDate != nil {
        structMap["endDate"] = u.EndDate
    }
    if u.DownloadAfterDate != nil {
        structMap["downloadAfterDate"] = u.DownloadAfterDate
    }
    if u.DownloadTimeWindowList != nil {
        structMap["downloadTimeWindowList"] = u.DownloadTimeWindowList
    }
    if u.InstallAfterDate != nil {
        structMap["installAfterDate"] = u.InstallAfterDate
    }
    if u.InstallTimeWindowList != nil {
        structMap["installTimeWindowList"] = u.InstallTimeWindowList
    }
    if u.DeviceList != nil {
        structMap["deviceList"] = u.DeviceList
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for UploadAndScheduleFileRequest.
// It customizes the JSON unmarshaling process for UploadAndScheduleFileRequest objects.
func (u *UploadAndScheduleFileRequest) UnmarshalJSON(input []byte) error {
    var temp tempUploadAndScheduleFileRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "campaignName", "fileName", "fileVersion", "distributionType", "startDate", "endDate", "downloadAfterDate", "downloadTimeWindowList", "installAfterDate", "installTimeWindowList", "deviceList")
    if err != nil {
    	return err
    }
    u.AdditionalProperties = additionalProperties
    
    u.CampaignName = temp.CampaignName
    u.FileName = temp.FileName
    u.FileVersion = temp.FileVersion
    u.DistributionType = temp.DistributionType
    u.StartDate = temp.StartDate
    u.EndDate = temp.EndDate
    u.DownloadAfterDate = temp.DownloadAfterDate
    u.DownloadTimeWindowList = temp.DownloadTimeWindowList
    u.InstallAfterDate = temp.InstallAfterDate
    u.InstallTimeWindowList = temp.InstallTimeWindowList
    u.DeviceList = temp.DeviceList
    return nil
}

// tempUploadAndScheduleFileRequest is a temporary struct used for validating the fields of UploadAndScheduleFileRequest.
type tempUploadAndScheduleFileRequest  struct {
    CampaignName           *string              `json:"campaignName,omitempty"`
    FileName               *string              `json:"fileName,omitempty"`
    FileVersion            *string              `json:"fileVersion,omitempty"`
    DistributionType       *string              `json:"distributionType,omitempty"`
    StartDate              *string              `json:"startDate,omitempty"`
    EndDate                *string              `json:"endDate,omitempty"`
    DownloadAfterDate      *string              `json:"downloadAfterDate,omitempty"`
    DownloadTimeWindowList []DownloadTimeWindow `json:"downloadTimeWindowList,omitempty"`
    InstallAfterDate       *string              `json:"installAfterDate,omitempty"`
    InstallTimeWindowList  []DownloadTimeWindow `json:"installTimeWindowList,omitempty"`
    DeviceList             []string             `json:"deviceList,omitempty"`
}
