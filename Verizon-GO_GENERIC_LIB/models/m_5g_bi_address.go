/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "fmt"
)

// M5GBiAddress represents a M5GBiAddress struct.
type M5GBiAddress struct {
    AddressLine1         *string                `json:"addressLine1,omitempty"`
    City                 *string                `json:"city,omitempty"`
    State                *string                `json:"state,omitempty"`
    Zip                  *string                `json:"zip,omitempty"`
    Zip4                 *string                `json:"zip+4,omitempty"`
    Phone                *string                `json:"phone,omitempty"`
    PhoneType            *string                `json:"phoneType,omitempty"`
    EmailAddress         *string                `json:"emailAddress,omitempty"`
    AdditionalProperties map[string]interface{} `json:"_"`
}

// String implements the fmt.Stringer interface for M5GBiAddress,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (m M5GBiAddress) String() string {
    return fmt.Sprintf(
    	"M5GBiAddress[AddressLine1=%v, City=%v, State=%v, Zip=%v, Zip4=%v, Phone=%v, PhoneType=%v, EmailAddress=%v, AdditionalProperties=%v]",
    	m.AddressLine1, m.City, m.State, m.Zip, m.Zip4, m.Phone, m.PhoneType, m.EmailAddress, m.AdditionalProperties)
}

// MarshalJSON implements the json.Marshaler interface for M5GBiAddress.
// It customizes the JSON marshaling process for M5GBiAddress objects.
func (m M5GBiAddress) MarshalJSON() (
    []byte,
    error) {
    if err := DetectConflictingProperties(m.AdditionalProperties,
        "addressLine1", "city", "state", "zip", "zip+4", "phone", "phoneType", "emailAddress"); err != nil {
        return []byte{}, err
    }
    return json.Marshal(m.toMap())
}

// toMap converts the M5GBiAddress object to a map representation for JSON marshaling.
func (m M5GBiAddress) toMap() map[string]any {
    structMap := make(map[string]any)
    MergeAdditionalProperties(structMap, m.AdditionalProperties)
    if m.AddressLine1 != nil {
        structMap["addressLine1"] = m.AddressLine1
    }
    if m.City != nil {
        structMap["city"] = m.City
    }
    if m.State != nil {
        structMap["state"] = m.State
    }
    if m.Zip != nil {
        structMap["zip"] = m.Zip
    }
    if m.Zip4 != nil {
        structMap["zip+4"] = m.Zip4
    }
    if m.Phone != nil {
        structMap["phone"] = m.Phone
    }
    if m.PhoneType != nil {
        structMap["phoneType"] = m.PhoneType
    }
    if m.EmailAddress != nil {
        structMap["emailAddress"] = m.EmailAddress
    }
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for M5GBiAddress.
// It customizes the JSON unmarshaling process for M5GBiAddress objects.
func (m *M5GBiAddress) UnmarshalJSON(input []byte) error {
    var temp tempM5GBiAddress
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    additionalProperties, err := ExtractAdditionalProperties[interface{}](input, "addressLine1", "city", "state", "zip", "zip+4", "phone", "phoneType", "emailAddress")
    if err != nil {
    	return err
    }
    m.AdditionalProperties = additionalProperties
    
    m.AddressLine1 = temp.AddressLine1
    m.City = temp.City
    m.State = temp.State
    m.Zip = temp.Zip
    m.Zip4 = temp.Zip4
    m.Phone = temp.Phone
    m.PhoneType = temp.PhoneType
    m.EmailAddress = temp.EmailAddress
    return nil
}

// tempM5GBiAddress is a temporary struct used for validating the fields of M5GBiAddress.
type tempM5GBiAddress  struct {
    AddressLine1 *string `json:"addressLine1,omitempty"`
    City         *string `json:"city,omitempty"`
    State        *string `json:"state,omitempty"`
    Zip          *string `json:"zip,omitempty"`
    Zip4         *string `json:"zip+4,omitempty"`
    Phone        *string `json:"phone,omitempty"`
    PhoneType    *string `json:"phoneType,omitempty"`
    EmailAddress *string `json:"emailAddress,omitempty"`
}
