/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package models

import (
    "encoding/json"
    "errors"
    "fmt"
    "github.com/google/uuid"
    "strings"
)

// ConnectionRequest represents a ConnectionRequest struct.
// Request for /clients/connection. It requires the device ID acquired in the registration request call; the geolocation of the device at the time of the request; and the network type (Verizon or non-Verizon). The system uses this information to determine with MQTT endpoint the device should use to connect the ETX Message Exchange.
type ConnectionRequest struct {
    // The generated ID (UUID v4) for the device. It can be used as:
    // - the MQTT Client ID when connecting to the Message Exchange system
    // - a parameter when asking for the connection endpoint
    // - a parameter when finishing the device registration
    // - a parameter when unregistering the device
    DeviceId    uuid.UUID      `json:"DeviceID"`
    // Geolocation of the device at the time of the connection request in GPS coordinates.
    Geolocation Geolocation    `json:"Geolocation"`
    // The type of the device's network connection at the time of the request. If the device is on the Verizon cellular network it should use the "VZ" value otherwise the "non-VZ" value.
    // Devices on the Verizon network can directly access the ETX Message Exchange on the MEC (Mobile Edge Compute server)
    NetworkType EtxNetworkType `json:"NetworkType"`
}

// String implements the fmt.Stringer interface for ConnectionRequest,
// providing a human-readable string representation useful for logging, debugging or displaying information.
func (c ConnectionRequest) String() string {
    return fmt.Sprintf(
    	"ConnectionRequest[DeviceId=%v, Geolocation=%v, NetworkType=%v]",
    	c.DeviceId, c.Geolocation, c.NetworkType)
}

// MarshalJSON implements the json.Marshaler interface for ConnectionRequest.
// It customizes the JSON marshaling process for ConnectionRequest objects.
func (c ConnectionRequest) MarshalJSON() (
    []byte,
    error) {
    return json.Marshal(c.toMap())
}

// toMap converts the ConnectionRequest object to a map representation for JSON marshaling.
func (c ConnectionRequest) toMap() map[string]any {
    structMap := make(map[string]any)
    structMap["DeviceID"] = c.DeviceId
    structMap["Geolocation"] = c.Geolocation.toMap()
    structMap["NetworkType"] = c.NetworkType
    return structMap
}

// UnmarshalJSON implements the json.Unmarshaler interface for ConnectionRequest.
// It customizes the JSON unmarshaling process for ConnectionRequest objects.
func (c *ConnectionRequest) UnmarshalJSON(input []byte) error {
    var temp tempConnectionRequest
    err := json.Unmarshal(input, &temp)
    if err != nil {
    	return err
    }
    err = temp.validate()
    if err != nil {
    	return err
    }
    
    c.DeviceId = *temp.DeviceId
    c.Geolocation = *temp.Geolocation
    c.NetworkType = *temp.NetworkType
    return nil
}

// tempConnectionRequest is a temporary struct used for validating the fields of ConnectionRequest.
type tempConnectionRequest  struct {
    DeviceId    *uuid.UUID      `json:"DeviceID"`
    Geolocation *Geolocation    `json:"Geolocation"`
    NetworkType *EtxNetworkType `json:"NetworkType"`
}

func (c *tempConnectionRequest) validate() error {
    var errs []string
    if c.DeviceId == nil {
        errs = append(errs, "required field `DeviceID` is missing for type `ConnectionRequest`")
    }
    if c.Geolocation == nil {
        errs = append(errs, "required field `Geolocation` is missing for type `ConnectionRequest`")
    }
    if c.NetworkType == nil {
        errs = append(errs, "required field `NetworkType` is missing for type `ConnectionRequest`")
    }
    if len(errs) == 0 {
        return nil
    }
    return errors.New(strings.Join (errs, "\n"))
}
