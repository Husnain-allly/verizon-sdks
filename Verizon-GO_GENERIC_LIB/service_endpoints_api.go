/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package verizon

import (
    "context"
    "github.com/apimatic/go-core-runtime/https"
    "github.com/apimatic/go-core-runtime/utilities"
    "verizon/errors"
    "verizon/models"
)

// ServiceEndpointsApi represents a controller struct.
type ServiceEndpointsApi struct {
    baseApi
}

// NewServiceEndpointsApi creates a new instance of ServiceEndpointsApi.
// It takes a baseController as a parameter and returns a pointer to the ServiceEndpointsApi.
func NewServiceEndpointsApi(baseApi baseApi) *ServiceEndpointsApi {
    serviceEndpointsApi := ServiceEndpointsApi{baseApi: baseApi}
    return &serviceEndpointsApi
}

// ListOptimalServiceEndpoints takes context, region, subscriberDensity, ueIdentityType, ueIdentity, serviceEndpointsIds as parameters and
// returns an models.ApiResponse with models.ListOptimalServiceEndpointsResult data and
// an error if there was an issue with the request or response.
// Returns a list of optimal Service Endpoints that client devices can connect to. **Note:** If a query is sent with all of the parameters, it will fail with a "400" error. You can search based on the following parameter combinations - Region plus Service Endpoints IDs and Subscriber density (density is optional but recommended), Region plus Service Endpoints IDs and UEIdentity(Including UEIdentity Type) and Service Endpoints IDs plus UEIdentity(Including UEIdentity Type).
func (s *ServiceEndpointsApi) ListOptimalServiceEndpoints(
    ctx context.Context,
    region *string,
    subscriberDensity *int,
    ueIdentityType *models.UserEquipmentIdentityType,
    ueIdentity *string,
    serviceEndpointsIds *string) (
    models.ApiResponse[models.ListOptimalServiceEndpointsResult],
    error) {
    req := s.prepareRequest(ctx, "GET", "/serviceendpoints")
    
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    if region != nil {
        req.QueryParam("region", *region)
    }
    if subscriberDensity != nil {
        req.QueryParam("subscriberDensity", *subscriberDensity)
    }
    if ueIdentityType != nil {
        req.QueryParam("UEIdentityType", *ueIdentityType)
    }
    if ueIdentity != nil {
        req.QueryParam("UEIdentity", *ueIdentity)
    }
    if serviceEndpointsIds != nil {
        req.QueryParam("serviceEndpointsIds", *serviceEndpointsIds)
    }
    var result models.ListOptimalServiceEndpointsResult
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ListOptimalServiceEndpointsResult](decoder)
    return models.NewApiResponse(result, resp), err
}

// RegisterServiceEndpoints takes context, body as parameters and
// returns an models.ApiResponse with models.RegisterServiceEndpointResult data and
// an error if there was an issue with the request or response.
// Register Service Endpoints of a deployed application to specified MEC Platforms.
func (s *ServiceEndpointsApi) RegisterServiceEndpoints(
    ctx context.Context,
    body []models.ResourcesEdgeHostedServiceWithProfileId) (
    models.ApiResponse[models.RegisterServiceEndpointResult],
    error) {
    req := s.prepareRequest(ctx, "POST", "/serviceendpoints")
    
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    req.Header("Content-Type", "application/json")
    req.Json(&body)
    var result models.RegisterServiceEndpointResult
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.RegisterServiceEndpointResult](decoder)
    return models.NewApiResponse(result, resp), err
}

// ListAllServiceEndpoints takes context as parameters and
// returns an models.ApiResponse with models.ListAllServiceEndpointsResult data and
// an error if there was an issue with the request or response.
// Returns a list of all registered service endpoints.
func (s *ServiceEndpointsApi) ListAllServiceEndpoints(ctx context.Context) (
    models.ApiResponse[models.ListAllServiceEndpointsResult],
    error) {
    req := s.prepareRequest(ctx, "GET", "/serviceendpointsall")
    
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    var result models.ListAllServiceEndpointsResult
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ListAllServiceEndpointsResult](decoder)
    return models.NewApiResponse(result, resp), err
}

// GetServiceEndpoint takes context, serviceEndpointsId as parameters and
// returns an models.ApiResponse with []models.ResourcesEdgeHostedServiceWithProfileId data and
// an error if there was an issue with the request or response.
// Returns endpoint information for all Service Endpoints registered to a specified serviceEndpointId.
func (s *ServiceEndpointsApi) GetServiceEndpoint(
    ctx context.Context,
    serviceEndpointsId string) (
    models.ApiResponse[[]models.ResourcesEdgeHostedServiceWithProfileId],
    error) {
    req := s.prepareRequest(ctx, "GET", "/serviceendpoints/%v")
    req.AppendTemplateParams(serviceEndpointsId)
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    
    var result []models.ResourcesEdgeHostedServiceWithProfileId
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[[]models.ResourcesEdgeHostedServiceWithProfileId](decoder)
    return models.NewApiResponse(result, resp), err
}

// UpdateServiceEndpoint takes context, serviceEndpointsId, body as parameters and
// returns an models.ApiResponse with models.UpdateServiceEndpointResult data and
// an error if there was an issue with the request or response.
// Update registered Service Endpoint information.
func (s *ServiceEndpointsApi) UpdateServiceEndpoint(
    ctx context.Context,
    serviceEndpointsId string,
    body []models.ResourcesEdgeHostedServiceWithProfileId) (
    models.ApiResponse[models.UpdateServiceEndpointResult],
    error) {
    req := s.prepareRequest(ctx, "PUT", "/serviceendpoints/%v")
    req.AppendTemplateParams(serviceEndpointsId)
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    req.Header("Content-Type", "application/json")
    req.Json(&body)
    
    var result models.UpdateServiceEndpointResult
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.UpdateServiceEndpointResult](decoder)
    return models.NewApiResponse(result, resp), err
}

// DeregisterServiceEndpoint takes context, serviceEndpointsId as parameters and
// returns an models.ApiResponse with models.DeregisterServiceEndpointResult data and
// an error if there was an issue with the request or response.
// Deregister an application's Service Endpoint from the MEC Platform(s).
func (s *ServiceEndpointsApi) DeregisterServiceEndpoint(
    ctx context.Context,
    serviceEndpointsId string) (
    models.ApiResponse[models.DeregisterServiceEndpointResult],
    error) {
    req := s.prepareRequest(ctx, "DELETE", "/serviceendpoints/%v")
    req.AppendTemplateParams(serviceEndpointsId)
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("VZ-M2M-Token"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "HTTP 400 Bad Request.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "401": {Message: "HTTP 401 Unauthorized.", Unmarshaller: errors.NewEdgeDiscoveryResult},
        "0": {Message: "HTTP 500 Internal Server Error.", Unmarshaller: errors.NewEdgeDiscoveryResult},
    })
    
    var result models.DeregisterServiceEndpointResult
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.DeregisterServiceEndpointResult](decoder)
    return models.NewApiResponse(result, resp), err
}
