/*
Package verizon

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
*/
package verizon

import (
    "context"
    "github.com/apimatic/go-core-runtime/https"
    "github.com/apimatic/go-core-runtime/utilities"
    "github.com/google/uuid"
    "net/http"
    "verizon/errors"
    "verizon/models"
)

// RegistrationApi represents a controller struct.
type RegistrationApi struct {
    baseApi
}

// NewRegistrationApi creates a new instance of RegistrationApi.
// It takes a baseController as a parameter and returns a pointer to the RegistrationApi.
func NewRegistrationApi(baseApi baseApi) *RegistrationApi {
    registrationApi := RegistrationApi{baseApi: baseApi}
    return &registrationApi
}

// RegisterEtxDevice takes context, body as parameters and
// returns an models.ApiResponse with models.ClientRegistrationResponse data and
// an error if there was an issue with the request or response.
// With this API call the user (client) registers its device or software service to the ETX system. Therefore, when a connection is initiated from the device or software service to the ETX system along with the credential provided by this registration call, then the connection will be authorized.
// - The user can register multiple devices or software services, which can all be used at the same time.
// - There rules set in the system that limit the type and subtype of the clients that are allowed to be registered under the VendorID. The rules are created based ont he agreement between the Vendor and Verizon.
// - The user will only be able to register a limited number of devices or software services under the same VendorID. This registration limit is specified by the agreement between the Vendor and Verizon.
// Note: The user needs to authenticate with their ThingSpace credentials using the Access/Bearer and Session/M2M tokens in order to call this API.
func (r *RegistrationApi) RegisterEtxDevice(
    ctx context.Context,
    body models.ClientRegistrationRequest) (
    models.ApiResponse[models.ClientRegistrationResponse],
    error) {
    req := r.prepareRequest(ctx, "POST", "/api/v2/clients/registration")
    
    req.BaseUrl("IMP Server")
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("SessionToken"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "Invalid Request", Unmarshaller: errors.NewEtxResponseError},
        "401": {Message: "Unauthorized Request", Unmarshaller: errors.NewEtxResponseError},
        "403": {Message: "Forbidden Request", Unmarshaller: errors.NewEtxResponseError},
        "429": {Message: "Too Many Requests", Unmarshaller: errors.NewEtxResponseError},
        "503": {Message: "Internal Server Error", Unmarshaller: errors.NewEtxResponseError},
        "0": {Message: "Forbidden", Unmarshaller: errors.NewEtxResponseError},
    })
    req.Header("Content-Type", "application/json")
    req.Json(&body)
    var result models.ClientRegistrationResponse
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ClientRegistrationResponse](decoder)
    return models.NewApiResponse(result, resp), err
}

// RenewEtxDevice takes context, deviceId, vendorId, body as parameters and
// returns an models.ApiResponse with models.ClientRegistrationResponse data and
// an error if there was an issue with the request or response.
// With this API call the user (client) can:
// - renew the certificate of a device or software service in the ETX system if the original certificate has expired. If the client's certificate expired or going to expire within 30 days and new certificate will be issued. If the certificate expires more than 30 days, the current certificate will be returned to the client.
// - complete its device or software service registration to the ETX system if the original registration request was not successful because of a pending certificate generation. Whenever the user receives a "client registration is pending" response (HTTP 202) from POST /clients/registration call. The client should initiate this PUT API call to finish the registration process and get the required certificate.
// Note: The user needs to authenticate with their ThingSpace credentials using the Access/Bearer and Session/M2M tokens in order to call this API.
func (r *RegistrationApi) RenewEtxDevice(
    ctx context.Context,
    deviceId uuid.UUID,
    vendorId string,
    body *interface{}) (
    models.ApiResponse[models.ClientRegistrationResponse],
    error) {
    req := r.prepareRequest(ctx, "PUT", "/api/v2/clients/registration")
    
    req.BaseUrl("IMP Server")
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("SessionToken"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "Invalid Request", Unmarshaller: errors.NewEtxResponseError},
        "401": {Message: "Unauthorized Request", Unmarshaller: errors.NewEtxResponseError},
        "403": {Message: "Forbidden Request", Unmarshaller: errors.NewEtxResponseError},
        "429": {Message: "Too Many Requests", Unmarshaller: errors.NewEtxResponseError},
        "503": {Message: "Internal Server Error", Unmarshaller: errors.NewEtxResponseError},
        "0": {Message: "Forbidden", Unmarshaller: errors.NewEtxResponseError},
    })
    req.Header("DeviceID", deviceId)
    req.Header("VendorID", vendorId)
    req.Header("Content-Type", "application/json")
    if body != nil {
        req.Json(*body)
    }
    var result models.ClientRegistrationResponse
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ClientRegistrationResponse](decoder)
    return models.NewApiResponse(result, resp), err
}

// UnregisterEtxDevice takes context, vendorId, deviceIDs as parameters and
// returns an *Response and
// an error if there was an issue with the request or response.
// With this API call the user (client) can unregister its devices and software services from the ETX system. The unregistered devices and services will no longer be able to use the ETX Message Exchange.
// Note: The user needs to authenticate with their ThingSpace credentials using the Access/Bearer and Session/M2M tokens in order to call this API.
func (r *RegistrationApi) UnregisterEtxDevice(
    ctx context.Context,
    vendorId string,
    deviceIDs []uuid.UUID) (
    *http.Response,
    error) {
    req := r.prepareRequest(ctx, "DELETE", "/api/v2/clients/registration")
    
    req.BaseUrl("IMP Server")
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("SessionToken"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "Invalid Request", Unmarshaller: errors.NewEtxResponseError},
        "401": {Message: "Unauthorized Request", Unmarshaller: errors.NewEtxResponseError},
        "403": {Message: "Forbidden Request", Unmarshaller: errors.NewEtxResponseError},
        "429": {Message: "Too Many Requests", Unmarshaller: errors.NewEtxResponseError},
        "503": {Message: "Internal Server Error", Unmarshaller: errors.NewEtxResponseError},
        "0": {Message: "Forbidden", Unmarshaller: errors.NewEtxResponseError},
    })
    req.Header("VendorID", vendorId)
    req.QueryParam("DeviceIDs", deviceIDs)
    httpCtx, err := req.Call()
    if err != nil {
        return httpCtx.Response, err
    }
    return httpCtx.Response, err
}

// GetEtxDeviceCertificate takes context, deviceId, imei, iccid as parameters and
// returns an models.ApiResponse with models.ClientPersistenceResponse data and
// an error if there was an issue with the request or response.
// With this API call the user can check the certificate of the device. At least one of the DeviceID, IMEI or ICCID is required to make the call.
// Note: The user needs to authenticate with their ThingSpace credentials using the Access/Bearer and Session/M2M tokens in order to call this API.
func (r *RegistrationApi) GetEtxDeviceCertificate(
    ctx context.Context,
    deviceId *uuid.UUID,
    imei *string,
    iccid *string) (
    models.ApiResponse[models.ClientPersistenceResponse],
    error) {
    req := r.prepareRequest(ctx, "GET", "/api/v2/clients/registration")
    
    req.BaseUrl("IMP Server")
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("SessionToken"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "Invalid request", Unmarshaller: errors.NewEtxResponseError},
        "401": {Message: "Unauthorized", Unmarshaller: errors.NewEtxResponseError},
        "403": {Message: "Forbidden Request", Unmarshaller: errors.NewEtxResponseError},
        "404": {Message: "Not Found", Unmarshaller: errors.NewEtxResponseError},
        "429": {Message: "Too Many Requests", Unmarshaller: errors.NewEtxResponseError},
        "500": {Message: "Internal server Error", Unmarshaller: errors.NewEtxResponseError},
        "0": {Message: "Forbidden", Unmarshaller: errors.NewEtxResponseError},
    })
    if deviceId != nil {
        req.QueryParam("DeviceID", *deviceId)
    }
    if imei != nil {
        req.QueryParam("IMEI", *imei)
    }
    if iccid != nil {
        req.QueryParam("ICCID", *iccid)
    }
    var result models.ClientPersistenceResponse
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ClientPersistenceResponse](decoder)
    return models.NewApiResponse(result, resp), err
}

// RetrieveMqtturl takes context, vendorId, body as parameters and
// returns an models.ApiResponse with models.ConnectionResponse data and
// an error if there was an issue with the request or response.
// With this API call the device or software service requests the MQTT URL for the location that it needs to connect. To determine the proper URL the device or software service needs to provide its ID (the one that was provided in the registration request), location (GPS coordinates), and whether it is on the Verizon cellular network or not.
// Note: The user needs to authenticate with their ThingSpace credentials using the Access/Bearer and Session/M2M tokens in order to call this API.
func (r *RegistrationApi) RetrieveMqtturl(
    ctx context.Context,
    vendorId string,
    body models.ConnectionRequest) (
    models.ApiResponse[models.ConnectionResponse],
    error) {
    req := r.prepareRequest(ctx, "POST", "/api/v2/clients/connection")
    
    req.BaseUrl("IMP Server")
    req.Authenticate(
        NewAndAuth(
            NewAuth("thingspace_oauth"),
            NewAuth("SessionToken"),
        ),
    )
    req.AppendErrors(map[string]https.ErrorBuilder[error]{
        "400": {Message: "Invalid request", Unmarshaller: errors.NewEtxResponseError},
        "401": {Message: "Unauthorized", Unmarshaller: errors.NewEtxResponseError},
        "403": {Message: "Forbidden Request", Unmarshaller: errors.NewEtxResponseError},
        "429": {Message: "Too Many Requests", Unmarshaller: errors.NewEtxResponseError},
        "503": {Message: "Internal server Error", Unmarshaller: errors.NewEtxResponseError},
        "0": {Message: "Forbidden", Unmarshaller: errors.NewEtxResponseError},
    })
    req.Header("VendorID", vendorId)
    req.Header("Content-Type", "application/json")
    req.Json(&body)
    var result models.ConnectionResponse
    decoder, resp, err := req.CallAsJson()
    if err != nil {
        return models.NewApiResponse(result, resp), err
    }
    
    result, err = utilities.DecodeResults[models.ConnectionResponse](decoder)
    return models.NewApiResponse(result, resp), err
}
